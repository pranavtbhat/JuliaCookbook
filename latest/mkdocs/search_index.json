{
    "docs": [
        {
            "location": "/", 
            "text": "JuliaCookbook\n\n\nA Cookbook for Julia. Contains recipes for:\n\n\n\n\nDataFrames\n\n\nTuples\n\n\nArrays\n\n\nStrings\n\n\nDictionaries\n\n\nDate Time\n\n\nRegular Expressions", 
            "title": "Home"
        }, 
        {
            "location": "/#juliacookbook", 
            "text": "A Cookbook for Julia. Contains recipes for:   DataFrames  Tuples  Arrays  Strings  Dictionaries  Date Time  Regular Expressions", 
            "title": "JuliaCookbook"
        }, 
        {
            "location": "/tuples/", 
            "text": "Tuple\n\n\nA tuple is an immutable, ordered sequence of elements. Once a tuple is created, it cannot be modified. A tuple is an easy way to pack elements, of any type, into a container. It can be also be thought of as a dynamic user defined type.\n\n\n\n\nCreating a tuple\n\n\nGeneral Syntax:\n\n\n(ITEM_1, ITEM_2 ... ITEM_N)\n\n\n\n\nThe contents of a tuple need not be homogenous:\n\n\njulia\n typeof((1, 1.0, \n1\n, true))\nTuple{Int64,Float64,String,Bool}\n\n\n\n\n\n\nTuple of tuples\n\n\nA tuple can contain tuples:\n\n\njulia\n typeof(((1,2), 3.0, \n4\n))\nTuple{Tuple{Int64,Int64},Float64,String}\n\n\n\n\n\n\nAccessing elements\n\n\nThe \ngetindex\n operator \n[]\n can be used to obtain an element at a specific position.\n\n\n\n\nGetting a single element (Unit Getindex)\n\n\njulia\n (1,2,3)[1]\n1\n\n\n\n\n\n\nGetting a range of elements (Ranged Getindex)\n\n\njulia\n (1,2,3,4,5)[2 : 4]\n\n\n\n\n\n\nGetting a set of discontiguous elements (Vector Getindex)\n\n\njulia\n (1,2,3,4,5)[[1,3,5]]\n\n\n\n\n\n\nSplice operator\n\n\nThe contents of an tuple can be unpacked into the arguments of a function, using the \n...\n operator. For example:\n\n\njulia\n f(x, y) = x + y\nf (generic function with 1 method)\n\njulia\n t = (1, 2)\n(1,2)\n\njulia\n f(t...)\n3", 
            "title": "Tuples"
        }, 
        {
            "location": "/tuples/#tuple", 
            "text": "A tuple is an immutable, ordered sequence of elements. Once a tuple is created, it cannot be modified. A tuple is an easy way to pack elements, of any type, into a container. It can be also be thought of as a dynamic user defined type.", 
            "title": "Tuple"
        }, 
        {
            "location": "/tuples/#creating-a-tuple", 
            "text": "General Syntax:  (ITEM_1, ITEM_2 ... ITEM_N)  The contents of a tuple need not be homogenous:  julia  typeof((1, 1.0,  1 , true))\nTuple{Int64,Float64,String,Bool}", 
            "title": "Creating a tuple"
        }, 
        {
            "location": "/tuples/#tuple-of-tuples", 
            "text": "A tuple can contain tuples:  julia  typeof(((1,2), 3.0,  4 ))\nTuple{Tuple{Int64,Int64},Float64,String}", 
            "title": "Tuple of tuples"
        }, 
        {
            "location": "/tuples/#accessing-elements", 
            "text": "The  getindex  operator  []  can be used to obtain an element at a specific position.", 
            "title": "Accessing elements"
        }, 
        {
            "location": "/tuples/#getting-a-single-element-unit-getindex", 
            "text": "julia  (1,2,3)[1]\n1", 
            "title": "Getting a single element (Unit Getindex)"
        }, 
        {
            "location": "/tuples/#getting-a-range-of-elements-ranged-getindex", 
            "text": "julia  (1,2,3,4,5)[2 : 4]", 
            "title": "Getting a range of elements (Ranged Getindex)"
        }, 
        {
            "location": "/tuples/#getting-a-set-of-discontiguous-elements-vector-getindex", 
            "text": "julia  (1,2,3,4,5)[[1,3,5]]", 
            "title": "Getting a set of discontiguous elements (Vector Getindex)"
        }, 
        {
            "location": "/tuples/#splice-operator", 
            "text": "The contents of an tuple can be unpacked into the arguments of a function, using the  ...  operator. For example:  julia  f(x, y) = x + y\nf (generic function with 1 method)\n\njulia  t = (1, 2)\n(1,2)\n\njulia  f(t...)\n3", 
            "title": "Splice operator"
        }, 
        {
            "location": "/strings/", 
            "text": "Strings\n\n\nA string in Julia is an immutable sequence of characters. In previous versions of Julia, the string type was implemented through an abstract type, \nAbstractString\n and concrete types such as \nASCIIString\n. Now, Julia provides a single \nString\n datatype.\n\n\n\n\nAccessing Substrings\n\n\nJulia doesn't allow modifications to \nString\n object, once it's created. However, it does provide ways of generating substrings. The getindex notation \n[]\n can be used on \nString\n, in the same way that you'd extract sub-arrays:\n\n\njulia\n str = \nabcdefg\n\n\nabcdefg\n\n\njulia\n str[1:3]\n\nabc\n\n\njulia\n str[5:end]\n\nefg\n\n\n\n\n\nIf your string has delimiting characters such as \n' ', '\\t' or ','\n, you can use the \nsplit\n function to split it:\n\n\njulia\n split(\n1,2,3,4,5\n, ',')\n5-element Array{SubString{String},1}:\n \n1\n\n \n2\n\n \n3\n\n \n4\n\n \n5\n\n\n\n\n\nYou can also combine smaller strings, while inserting characters between them:\n\n\njulia\n join([\n1\n, \n2\n, \n3\n, \n4\n, \n5\n], ',')\n\n1,2,3,4,5\n\n\n\n\n\n\n\nProcessing a String One Character at a Time\n\n\nStrings in Julia are similar to Arrays. You can iterate over the characters in a \nString\n the same way you'd iterate over the elements in an array:\n\n\njulia\n for ch in \nabcd\n\n          println(ch)\n       end\n a\n b\n c\n d\n\n\n\n\nYou can also use the \nmap\n function if you want to perform the same operation over every character in the \nString\n:\n\n\njulia\n map(x -\n x + 1, \nabcd\n) # Increment every character in the string\n\nbcde\n\n\n\n\n\n\n\nConcatentating strings\n\n\nStrings can be concatenated using the \nstring\n function. Non string objects are converted into strings, as long as the \nshow\n function is defined.\n\n\njulia\n string(\nOne \n, \nTwo \n, 3, ' ', :four)\n\nOne Two 3 four\n\n\n\n\n\nAn array of strings can be joined together, with separators, using the \njoin\n function\n\n\njulia\n join([1, 2, 3, 4, 5, 6], \n, \n)\n\n1, 2, 3, 4, 5, 6\n\n\n\n\n\n\n\nChecking if one string is a substring of the other\n\n\nThe \ncontains\n function can be used to check string containment.\n\n\njulia\n contains(\nabcd\n, \nab\n)\ntrue\n\n\n\n\n\n\nReversing a String by Word or Character\n\n\nTo reverse every character in the \nString\n, use the \nreverse\n function:\n\n\njulia\n reverse(\nabcdefg\n)\n\ngfedcba\n\n\n\n\n\nIf you want to reverse the individual words in the \nString\n:\n\n\n\n\nFirst split the string into constituent words using \nsplit\n\n\nPerform a reversal on every word\n\n\nUse \njoin\n to combine the words\n\n\n\n\njulia\n join(map(reverse, split(\nabc def ghi jkl\n, ' ')), ' ')\n\ncba fed ihg lkj\n\n\n\n\n\n\n\nExpanding Tabs\n\n\nIf you have a file with tab-spaces that you'd like to replace space-indents, use the \nreplace\n function:\n\n\njulia\n replace(\n1\\t2\\t3\\t4\n, r\n(\\t)\n, s\n   \n)\n\n1   2   3   4\n\n\n\n\n\n\n\nExpanding Variables in User Input (Interpolation)\n\n\nThe \n$\n notation can be used to substitute a user defined variable or expression (its string equivalent to be more precise) into any position in a string:\n\n\njulia\n \ntwo = $(1 + 1)\n\n\ntwo = 2\n\n\njulia\n a = \nHello\n\n\njulia\n \n$a World\n\n\nHello World\n\n\n\n\n\n\n\nChanging Case\n\n\nA string can be converted to lower case using the \nlowercase\n function, and the \nislower\n function can be used to see if a string is in lower case:\n\n\njulia\n lowercase(\naBcD\n)\n\nabcd\n\n\njulia\n islower(\nabcd\n)\ntrue\n\n\n\n\nSimilarly, the \nuppercase\n function can be used to convert an entire string to uppercase, and the \nisupper\n function can be used to see if a string is in lower case:\n\n\njulia\n uppercase(\naBcD\n)\n\nABCD\n\n\njulia\n isupper(\nABCD\n)\ntrue\n\n\n\n\n\n\nTrimming Blanks from the Ends of a String\n\n\nThe \nrstrip\n function can be used to remove trailing blanks from a string:\n\n\njulia\n rstrip(\nHello World       \n)\n\nHello World\n\n\n\n\n\n\n\nParsing Delimited Data\n\n\nParsing a CSV file with strings can be challenging, since the string fields can contain commas themselves. The best way to parse such a file, would be to use the \nreadcsv\n function. \nreadcsv\n will not consider the commas inside strings, when splitting the lines of the files.\n\n\njulia\n buf = IOBuffer(\n\\\nabcd\\\n,\\\nabc,d\\\n,\\\nab,c,d\\\n,\\\na,b,c,d\\\n)\n\njulia\n readcsv(buf)\n1\u00d74 Array{Any,2}:\n \nabcd\n  \nabc,d\n  \nab,c,d\n  \na,b,c,d", 
            "title": "Strings"
        }, 
        {
            "location": "/strings/#strings", 
            "text": "A string in Julia is an immutable sequence of characters. In previous versions of Julia, the string type was implemented through an abstract type,  AbstractString  and concrete types such as  ASCIIString . Now, Julia provides a single  String  datatype.", 
            "title": "Strings"
        }, 
        {
            "location": "/strings/#accessing-substrings", 
            "text": "Julia doesn't allow modifications to  String  object, once it's created. However, it does provide ways of generating substrings. The getindex notation  []  can be used on  String , in the same way that you'd extract sub-arrays:  julia  str =  abcdefg  abcdefg \n\njulia  str[1:3] abc \n\njulia  str[5:end] efg   If your string has delimiting characters such as  ' ', '\\t' or ',' , you can use the  split  function to split it:  julia  split( 1,2,3,4,5 , ',')\n5-element Array{SubString{String},1}:\n  1 \n  2 \n  3 \n  4 \n  5   You can also combine smaller strings, while inserting characters between them:  julia  join([ 1 ,  2 ,  3 ,  4 ,  5 ], ',') 1,2,3,4,5", 
            "title": "Accessing Substrings"
        }, 
        {
            "location": "/strings/#processing-a-string-one-character-at-a-time", 
            "text": "Strings in Julia are similar to Arrays. You can iterate over the characters in a  String  the same way you'd iterate over the elements in an array:  julia  for ch in  abcd \n          println(ch)\n       end\n a\n b\n c\n d  You can also use the  map  function if you want to perform the same operation over every character in the  String :  julia  map(x -  x + 1,  abcd ) # Increment every character in the string bcde", 
            "title": "Processing a String One Character at a Time"
        }, 
        {
            "location": "/strings/#concatentating-strings", 
            "text": "Strings can be concatenated using the  string  function. Non string objects are converted into strings, as long as the  show  function is defined.  julia  string( One  ,  Two  , 3, ' ', :four) One Two 3 four   An array of strings can be joined together, with separators, using the  join  function  julia  join([1, 2, 3, 4, 5, 6],  ,  ) 1, 2, 3, 4, 5, 6", 
            "title": "Concatentating strings"
        }, 
        {
            "location": "/strings/#checking-if-one-string-is-a-substring-of-the-other", 
            "text": "The  contains  function can be used to check string containment.  julia  contains( abcd ,  ab )\ntrue", 
            "title": "Checking if one string is a substring of the other"
        }, 
        {
            "location": "/strings/#reversing-a-string-by-word-or-character", 
            "text": "To reverse every character in the  String , use the  reverse  function:  julia  reverse( abcdefg ) gfedcba   If you want to reverse the individual words in the  String :   First split the string into constituent words using  split  Perform a reversal on every word  Use  join  to combine the words   julia  join(map(reverse, split( abc def ghi jkl , ' ')), ' ') cba fed ihg lkj", 
            "title": "Reversing a String by Word or Character"
        }, 
        {
            "location": "/strings/#expanding-tabs", 
            "text": "If you have a file with tab-spaces that you'd like to replace space-indents, use the  replace  function:  julia  replace( 1\\t2\\t3\\t4 , r (\\t) , s     ) 1   2   3   4", 
            "title": "Expanding Tabs"
        }, 
        {
            "location": "/strings/#expanding-variables-in-user-input-interpolation", 
            "text": "The  $  notation can be used to substitute a user defined variable or expression (its string equivalent to be more precise) into any position in a string:  julia   two = $(1 + 1)  two = 2 \n\njulia  a =  Hello \n\njulia   $a World  Hello World", 
            "title": "Expanding Variables in User Input (Interpolation)"
        }, 
        {
            "location": "/strings/#changing-case", 
            "text": "A string can be converted to lower case using the  lowercase  function, and the  islower  function can be used to see if a string is in lower case:  julia  lowercase( aBcD ) abcd \n\njulia  islower( abcd )\ntrue  Similarly, the  uppercase  function can be used to convert an entire string to uppercase, and the  isupper  function can be used to see if a string is in lower case:  julia  uppercase( aBcD ) ABCD \n\njulia  isupper( ABCD )\ntrue", 
            "title": "Changing Case"
        }, 
        {
            "location": "/strings/#trimming-blanks-from-the-ends-of-a-string", 
            "text": "The  rstrip  function can be used to remove trailing blanks from a string:  julia  rstrip( Hello World        ) Hello World", 
            "title": "Trimming Blanks from the Ends of a String"
        }, 
        {
            "location": "/strings/#parsing-delimited-data", 
            "text": "Parsing a CSV file with strings can be challenging, since the string fields can contain commas themselves. The best way to parse such a file, would be to use the  readcsv  function.  readcsv  will not consider the commas inside strings, when splitting the lines of the files.  julia  buf = IOBuffer( \\ abcd\\ ,\\ abc,d\\ ,\\ ab,c,d\\ ,\\ a,b,c,d\\ )\n\njulia  readcsv(buf)\n1\u00d74 Array{Any,2}:\n  abcd    abc,d    ab,c,d    a,b,c,d", 
            "title": "Parsing Delimited Data"
        }, 
        {
            "location": "/dicts/", 
            "text": "Dictionaries\n\n\nJulia supports the \nDict\n data structure, a simple implementation of a look-up table or hashmap.\n\n\n\n\nCreating a dictionary\n\n\nThe \nDict\n constructor accepts a list of pairs as arguments, and returns a dictionary.\n\n\njulia\n Dict(\nOne\n =\n 1, \nTwo\n =\n 2, \nThree\n =\n 3)\nDict{String,Int64} with 3 entries:\n  \nOne\n   =\n 1\n  \nTwo\n   =\n 2\n  \nThree\n =\n 3\n\n\n\n\nThe \nDict\n constructor also allows for comprehension-like syntax:\n\n\njulia\n Dict(\n$i\n =\n i for i in 1 : 3)\nDict{String,Int64} with 3 entries:\n  \n1\n =\n 1\n  \n2\n =\n 2\n  \n3\n =\n 3\n\n\n\n\n\n\nAccessing the elements of a dictionary\n\n\nThe getindex operator can be used to fetch the value corresponding to the input key. However, if the key doesn't exist in the dictionary, an error is thrown.\n\n\nd = Dict(\nOne\n =\n 1, \nTwo\n =\n 2, \nThree\n =\n 3)\n\njulia\n d[\nOne\n]\n1\n\njulia\n d[\nFour\n]\nERROR: KeyError: key \nFour\n not found\n\n\n\n\nAlternativey, the \nget\n function can be used to fetch the value corresponding to the key, while specifying a default value.\n\n\njulia\n get(d, \nFour\n, 4)\n4\n\n\n\n\n\n\nMap\n\n\nThe map function can be used to perform an operation on every key/value in a dictionary, producing a new dictionary:\n\n\nd = Dict(\nOne\n =\n 1, \nTwo\n =\n 2, \nThree\n =\n 3)\n\njulia\n map(x -\n (string(x[1], \ns\n) =\n fill(x[2], x[2])), d)\nDict{String,Array{Int64,1}} with 3 entries:\n  \nTwos\n   =\n [2,2]\n  \nOnes\n   =\n [1]\n  \nThrees\n =\n [3,3,3]\n\n\n\n\n\n\nFilter\n\n\nThe \nfilter\n function can be used to remove key-value pairs that do not satisfy a condition.\n\n\nd = Dict(\nOne\n =\n 1, \nTwo\n =\n 2, \nThree\n =\n 3)\n\njulia\n filter((key, value) -\n value % 2 == 1, d)\nDict{String,Int64} with 2 entries:\n  \nOne\n   =\n 1\n  \nThree\n =\n 3", 
            "title": "Dictionaries"
        }, 
        {
            "location": "/dicts/#dictionaries", 
            "text": "Julia supports the  Dict  data structure, a simple implementation of a look-up table or hashmap.", 
            "title": "Dictionaries"
        }, 
        {
            "location": "/dicts/#creating-a-dictionary", 
            "text": "The  Dict  constructor accepts a list of pairs as arguments, and returns a dictionary.  julia  Dict( One  =  1,  Two  =  2,  Three  =  3)\nDict{String,Int64} with 3 entries:\n   One    =  1\n   Two    =  2\n   Three  =  3  The  Dict  constructor also allows for comprehension-like syntax:  julia  Dict( $i  =  i for i in 1 : 3)\nDict{String,Int64} with 3 entries:\n   1  =  1\n   2  =  2\n   3  =  3", 
            "title": "Creating a dictionary"
        }, 
        {
            "location": "/dicts/#accessing-the-elements-of-a-dictionary", 
            "text": "The getindex operator can be used to fetch the value corresponding to the input key. However, if the key doesn't exist in the dictionary, an error is thrown.  d = Dict( One  =  1,  Two  =  2,  Three  =  3)\n\njulia  d[ One ]\n1\n\njulia  d[ Four ]\nERROR: KeyError: key  Four  not found  Alternativey, the  get  function can be used to fetch the value corresponding to the key, while specifying a default value.  julia  get(d,  Four , 4)\n4", 
            "title": "Accessing the elements of a dictionary"
        }, 
        {
            "location": "/dicts/#map", 
            "text": "The map function can be used to perform an operation on every key/value in a dictionary, producing a new dictionary:  d = Dict( One  =  1,  Two  =  2,  Three  =  3)\n\njulia  map(x -  (string(x[1],  s ) =  fill(x[2], x[2])), d)\nDict{String,Array{Int64,1}} with 3 entries:\n   Twos    =  [2,2]\n   Ones    =  [1]\n   Threes  =  [3,3,3]", 
            "title": "Map"
        }, 
        {
            "location": "/dicts/#filter", 
            "text": "The  filter  function can be used to remove key-value pairs that do not satisfy a condition.  d = Dict( One  =  1,  Two  =  2,  Three  =  3)\n\njulia  filter((key, value) -  value % 2 == 1, d)\nDict{String,Int64} with 2 entries:\n   One    =  1\n   Three  =  3", 
            "title": "Filter"
        }, 
        {
            "location": "/arrays/arrays/", 
            "text": "Arrays\n\n\nThis file contains recipes for common problems related to arrays. The problem shown here are from the arrays section in the \nPerl Cookbook\n.\n\n\nIn Julia, an array is an ordered collection of elements. We will be dealing with the \nArray{T,N}\n data structure exclusively, and won't be dealing with other subtypes of  \nAbstractArray{T,N}\n.\n\n\n\n\nReferences\n\n\n\n\nJulia Array documentation\n\n\nJulia Array Wiki", 
            "title": "Introduction"
        }, 
        {
            "location": "/arrays/arrays/#arrays", 
            "text": "This file contains recipes for common problems related to arrays. The problem shown here are from the arrays section in the  Perl Cookbook .  In Julia, an array is an ordered collection of elements. We will be dealing with the  Array{T,N}  data structure exclusively, and won't be dealing with other subtypes of   AbstractArray{T,N} .", 
            "title": "Arrays"
        }, 
        {
            "location": "/arrays/arrays/#references", 
            "text": "Julia Array documentation  Julia Array Wiki", 
            "title": "References"
        }, 
        {
            "location": "/arrays/creating/", 
            "text": "Creating an array\n\n\n\n\n1 Dimensional Arrays\n\n\nJulia provides multiple methods to create arrays. An array can be created by specifying all elements in a comma separated list.\n\n\njulia\n [1, 2, 3, 4, 5]\n5-element Array{Int64,1}:\n 1\n 2\n 3\n 4\n 5\n\n\n\n\nAn array of type \nAny\n can support elements of all types:\n\n\njulia\n Any[1, 1.0, \n1\n, true]\n4-element Array{Any,1}:\n 1   \n 1.0\n \n1\n\n true\n\n\n\n\nAn uninitialized array of type T can be created using the \nArray\n constructor:\n\n\njulia\n Array(Any, 5)\n5-element Array{Any,1}:\n #undef\n #undef\n #undef\n #undef\n #undef\n\n\n\n\nAn array of zero valued elements can be created using the \nzeros\n function. The function can be called as \nzeros(T, n)\n where \nT\n is a type and \nn\n is the size of the array:\n\n\njulia\n zeros(Float64, 5)\n5-element Array{Float64,1}:\n 0.0\n 0.0\n 0.0\n 0.0\n 0.0\n\n\n\n\nSimilarly, an array of ones can be created using the \nones\n function:\n\n\n julia\n ones(Bool, 5)\n5-element Array{Bool,1}:\n true\n true\n true\n true\n true\n\n\n\n\nAn array of random numbers can be created using the \nrand\n function. The function can be called as \nrand(T, n)\n where \nT\n is a numeric type and \nn\n is the size of the array.\n\n\njulia\n rand(Int, 3)\nrand(Int, 3)\n3-element Array{Int64,1}:\n  337280521677695220\n 9086787289687117354\n 7160428826622140198\n\n\n\n\nTo create an array with elements in a specific range:\n\n\njulia\n rand(1 : 10, 3)\n3-element Array{Int64,1}:\n  4\n 10\n  4\n\n\n\n\n\n\n2 Dimensional Arrays\n\n\nA 2D array can be created by specifying all elements in blank separated columns and semicolon separated rows:\n\n\njulia\n [1 2 3 4 ; 5 6 7 8]\n2\u00d74 Array{Int64,2}:\n 1  2  3  4\n 5  6  7  8\n\n\n\n\nAn uninitialized 2D array of type \nT\n can be created as \nArray(T, m, n)\n, where \nm\n is the number of rows, and \nn\n is the number of columns:\n\n\njulia\n Array(Bool, 3, 3)\n3\u00d73 Array{Bool,2}:\n false  false  false\n false   true  false\n false  false  false\n\n\n\n\nThe \nzeros\n, \nones\n and \nrand\n function can be used to produce 2D arrays, by supplying the length of the second dimension.\n\n\njulia\n zeros(Float64, 3, 3)\n3\u00d73 Array{Float64,2}:\n 0.0  0.0  0.0\n 0.0  0.0  0.0\n 0.0  0.0  0.0\n\njulia\n ones(Bool, 3, 3)\n3\u00d73 Array{Bool,2}:\n true  true  true\n true  true  true\n true  true  true\n\njulia\n rand(1 : 5, 2, 2)\n2\u00d72 Array{Int64,2}:\n 2  5\n 4  2", 
            "title": "Creation"
        }, 
        {
            "location": "/arrays/creating/#creating-an-array", 
            "text": "", 
            "title": "Creating an array"
        }, 
        {
            "location": "/arrays/creating/#1-dimensional-arrays", 
            "text": "Julia provides multiple methods to create arrays. An array can be created by specifying all elements in a comma separated list.  julia  [1, 2, 3, 4, 5]\n5-element Array{Int64,1}:\n 1\n 2\n 3\n 4\n 5  An array of type  Any  can support elements of all types:  julia  Any[1, 1.0,  1 , true]\n4-element Array{Any,1}:\n 1   \n 1.0\n  1 \n true  An uninitialized array of type T can be created using the  Array  constructor:  julia  Array(Any, 5)\n5-element Array{Any,1}:\n #undef\n #undef\n #undef\n #undef\n #undef  An array of zero valued elements can be created using the  zeros  function. The function can be called as  zeros(T, n)  where  T  is a type and  n  is the size of the array:  julia  zeros(Float64, 5)\n5-element Array{Float64,1}:\n 0.0\n 0.0\n 0.0\n 0.0\n 0.0  Similarly, an array of ones can be created using the  ones  function:   julia  ones(Bool, 5)\n5-element Array{Bool,1}:\n true\n true\n true\n true\n true  An array of random numbers can be created using the  rand  function. The function can be called as  rand(T, n)  where  T  is a numeric type and  n  is the size of the array.  julia  rand(Int, 3)\nrand(Int, 3)\n3-element Array{Int64,1}:\n  337280521677695220\n 9086787289687117354\n 7160428826622140198  To create an array with elements in a specific range:  julia  rand(1 : 10, 3)\n3-element Array{Int64,1}:\n  4\n 10\n  4", 
            "title": "1 Dimensional Arrays"
        }, 
        {
            "location": "/arrays/creating/#2-dimensional-arrays", 
            "text": "A 2D array can be created by specifying all elements in blank separated columns and semicolon separated rows:  julia  [1 2 3 4 ; 5 6 7 8]\n2\u00d74 Array{Int64,2}:\n 1  2  3  4\n 5  6  7  8  An uninitialized 2D array of type  T  can be created as  Array(T, m, n) , where  m  is the number of rows, and  n  is the number of columns:  julia  Array(Bool, 3, 3)\n3\u00d73 Array{Bool,2}:\n false  false  false\n false   true  false\n false  false  false  The  zeros ,  ones  and  rand  function can be used to produce 2D arrays, by supplying the length of the second dimension.  julia  zeros(Float64, 3, 3)\n3\u00d73 Array{Float64,2}:\n 0.0  0.0  0.0\n 0.0  0.0  0.0\n 0.0  0.0  0.0\n\njulia  ones(Bool, 3, 3)\n3\u00d73 Array{Bool,2}:\n true  true  true\n true  true  true\n true  true  true\n\njulia  rand(1 : 5, 2, 2)\n2\u00d72 Array{Int64,2}:\n 2  5\n 4  2", 
            "title": "2 Dimensional Arrays"
        }, 
        {
            "location": "/arrays/map/", 
            "text": "Doing Something with Every Element in a List\n\n\nMost use cases of Arrays involve iterating over each element in the array, and applying some operation on each element. The result could be new array, changes to the same array, or an aggregate of some kind.\n\n\n\n\nIteration\n\n\nJulia provides the \nin\n operator which when used in conjunction with the for loop, can be used to iterate over every element in the list:\n\n\njulia\n for item in [\nA\n,\nB\n,\nC\n]\n          println(item)\n       end\nA\nB\nC\n\n\n\n\nTo iterate over every element in the list and keep track of the index of the element, the \nenumerate\n iterator can be used:\n\n\njulia\n for (index,item) in enumerate([\nA\n,\nB\n,\nC\n])\n           println(\n$(index) -\n $(item)\n)\n       end\n1 -\n A\n2 -\n B\n3 -\n C\n\n\n\n\nTo simply iterate over the indices of an array, the \neachindex\n function can be used:\n\n\njulia\n for index in eachindex([\nA\n,\nB\n,\nC\n])\n           println(index)\n       end\n1\n2\n3\n\n\n\n\nTo iterate over multiple arrays at the same time, use the \nzip\n iterator:\n\n\njulia\n for (item1,item2) in zip([\nA\n,\nB\n,\nC\n], [\na\n,\nb\n,\nc\n])\n          println(item1, \n \n, item2)\n       end\n A a\n B b\n C c\n\n\n\n\n\n\nMap\n\n\nIf you want to perform the same operation, specified by a function \nf\n, on every element of an array: \nmap(f, ARRAY)\n. For example, to increment every element in the array by one:\n\n\njulia\n map(x -\n x + 1, [1,2,3])\n3-element Array{Int64,1}:\n 2\n 3\n 4\n\n\n\n\n\n\nMap Reduce\n\n\nIf you want to perform an operation on every element in the array, and then perform some sort of aggregation on the result (min, max, sum etc), the \nmapreduce\n function can come in handy. For example, to find the sum of the squares of the first five numbers\n\n\njulia\n mapreduce(x-\nx^2, +, [1,2,3,4,5])\n55", 
            "title": "Iteration"
        }, 
        {
            "location": "/arrays/map/#doing-something-with-every-element-in-a-list", 
            "text": "Most use cases of Arrays involve iterating over each element in the array, and applying some operation on each element. The result could be new array, changes to the same array, or an aggregate of some kind.", 
            "title": "Doing Something with Every Element in a List"
        }, 
        {
            "location": "/arrays/map/#iteration", 
            "text": "Julia provides the  in  operator which when used in conjunction with the for loop, can be used to iterate over every element in the list:  julia  for item in [ A , B , C ]\n          println(item)\n       end\nA\nB\nC  To iterate over every element in the list and keep track of the index of the element, the  enumerate  iterator can be used:  julia  for (index,item) in enumerate([ A , B , C ])\n           println( $(index) -  $(item) )\n       end\n1 -  A\n2 -  B\n3 -  C  To simply iterate over the indices of an array, the  eachindex  function can be used:  julia  for index in eachindex([ A , B , C ])\n           println(index)\n       end\n1\n2\n3  To iterate over multiple arrays at the same time, use the  zip  iterator:  julia  for (item1,item2) in zip([ A , B , C ], [ a , b , c ])\n          println(item1,    , item2)\n       end\n A a\n B b\n C c", 
            "title": "Iteration"
        }, 
        {
            "location": "/arrays/map/#map", 
            "text": "If you want to perform the same operation, specified by a function  f , on every element of an array:  map(f, ARRAY) . For example, to increment every element in the array by one:  julia  map(x -  x + 1, [1,2,3])\n3-element Array{Int64,1}:\n 2\n 3\n 4", 
            "title": "Map"
        }, 
        {
            "location": "/arrays/map/#map-reduce", 
            "text": "If you want to perform an operation on every element in the array, and then perform some sort of aggregation on the result (min, max, sum etc), the  mapreduce  function can come in handy. For example, to find the sum of the squares of the first five numbers  julia  mapreduce(x- x^2, +, [1,2,3,4,5])\n55", 
            "title": "Map Reduce"
        }, 
        {
            "location": "/arrays/reorder/", 
            "text": "Reordering the elements\n\n\n\n\nSorting\n\n\nJulia provides the highly customizable \nsort\n method to put the elements of an array in a specific order. \nsort\n leaves the original array intact, and produces a new sorted array by copying in the elements from the original array. \nSort\n accepts the following keyword arguments:\n\n\n\n\nalg\n : The sorting algorithm to be used. Can be one of \n[InsertionSort, MergeSort, QuickSort]\n.\n\n\nby\n  : Pass in a function to be applied on each element of the array before sorting.\n\n\nlt\n  : Pass in a function that can be used to compare any two elements in the array.\n\n\nrev\n : Boolean argument which sorts in reverse, or decreasing order, when set to true.\n\n\n\n\nThe \nsort\n function will never modify the elements in the array.\n\n\njulia\n sort([3,1,2])\n3-element Array{Int64,1}:\n 1\n 2\n 3\n\njulia\n sort([1,2,3], by = x -\n - x)\n3-element Array{Int64,1}:\n 3\n 2\n 1\n\njulia\n sort([1,2,3], lt = (x,y) -\n !(x \n y))\n3-element Array{Int64,1}:\n 3\n 2\n 1\n\njulia\n sort([1,2,3], rev=true)\n3-element Array{Int64,1}:\n 3\n 2\n 1\n\n\n\n\nIf you'd like to sort the original array, without creating a copy, use the \nsort!\n function instead.\n\n\n\n\nReverse\n\n\nTo simply reverse the contents of an array:\n\n\njulia\n reverse([1,2,3])\n3-element Array{Int64,1}:\n 3\n 2\n 1\n\n\n\n\nLike \nsort\n, the \nreverse\n function creates a copy of the argument array and reverses that. If you'd like to reverse the input array, use the \nreverse!\n function.\n\n\n\n\nRandomize\n\n\nTo put the elements of an array in a random order, use the \nshuffle\n function:\n\n\njulia\n shuffle([1,2,3,4,5])\n5-element Array{Int64,1}:\n 4\n 1\n 5\n 3\n 2\n\n\n\n\nIf you want to randomize the original array itself, instead of its copy, use the \nshuffle!\n function.", 
            "title": "Reordering"
        }, 
        {
            "location": "/arrays/reorder/#reordering-the-elements", 
            "text": "", 
            "title": "Reordering the elements"
        }, 
        {
            "location": "/arrays/reorder/#sorting", 
            "text": "Julia provides the highly customizable  sort  method to put the elements of an array in a specific order.  sort  leaves the original array intact, and produces a new sorted array by copying in the elements from the original array.  Sort  accepts the following keyword arguments:   alg  : The sorting algorithm to be used. Can be one of  [InsertionSort, MergeSort, QuickSort] .  by   : Pass in a function to be applied on each element of the array before sorting.  lt   : Pass in a function that can be used to compare any two elements in the array.  rev  : Boolean argument which sorts in reverse, or decreasing order, when set to true.   The  sort  function will never modify the elements in the array.  julia  sort([3,1,2])\n3-element Array{Int64,1}:\n 1\n 2\n 3\n\njulia  sort([1,2,3], by = x -  - x)\n3-element Array{Int64,1}:\n 3\n 2\n 1\n\njulia  sort([1,2,3], lt = (x,y) -  !(x   y))\n3-element Array{Int64,1}:\n 3\n 2\n 1\n\njulia  sort([1,2,3], rev=true)\n3-element Array{Int64,1}:\n 3\n 2\n 1  If you'd like to sort the original array, without creating a copy, use the  sort!  function instead.", 
            "title": "Sorting"
        }, 
        {
            "location": "/arrays/reorder/#reverse", 
            "text": "To simply reverse the contents of an array:  julia  reverse([1,2,3])\n3-element Array{Int64,1}:\n 3\n 2\n 1  Like  sort , the  reverse  function creates a copy of the argument array and reverses that. If you'd like to reverse the input array, use the  reverse!  function.", 
            "title": "Reverse"
        }, 
        {
            "location": "/arrays/reorder/#randomize", 
            "text": "To put the elements of an array in a random order, use the  shuffle  function:  julia  shuffle([1,2,3,4,5])\n5-element Array{Int64,1}:\n 4\n 1\n 5\n 3\n 2  If you want to randomize the original array itself, instead of its copy, use the  shuffle!  function.", 
            "title": "Randomize"
        }, 
        {
            "location": "/arrays/setlike/", 
            "text": "Set-like operations\n\n\n\n\nFinding unique elements in the list\n\n\nThe \nunique\n function produces the list of unique elements present in an array:\n\n\njulia\n unique([1,1,2,2,3,3,4,4])\n4-element Array{Int64,1}:\n 1\n 2\n 3\n 4\n\n\n\n\nThe \nunique\n function works faster when the input list comprises of sorted elements.\n\n\n\n\nFinding Elements in One Array but Not Another\n\n\nTo find the elements that are in one array, but not another, use \nsetdiff\n. For example:\n\n\njulia\n setdiff([1,2,3,4], [1,2,5,6])\n2-element Array{Int64,1}:\n 3\n 4\n\n\n\n\nIf your arrays have elements repeated, then use:\n\n\njulia\n filter(x -\n !in(x, [1,2,4]), [1,2,2,3,3,4,6,7,7])\n5-element Array{Int64,1}:\n 3\n 3\n 6\n 7\n 7\n\n\n\n\n\n\nSet union\n\n\nThe \nunion\n function can be used to perform the set-union operation:\n\n\njulia\n union([1,2,3], [1,4,5])\n5-element Array{Int64,1}:\n 1\n 2\n 3\n 4\n 5\n\n\n\n\n\n\nSet intersection\n\n\nThe \nintersect\n function can be used to perform the set-intersection operation:\n\n\njulia\n intersect([1,2,3,4], [1,2,3,5])\n3-element Array{Int64,1}:\n 1\n 2\n 3", 
            "title": "Set Operations"
        }, 
        {
            "location": "/arrays/setlike/#set-like-operations", 
            "text": "", 
            "title": "Set-like operations"
        }, 
        {
            "location": "/arrays/setlike/#finding-unique-elements-in-the-list", 
            "text": "The  unique  function produces the list of unique elements present in an array:  julia  unique([1,1,2,2,3,3,4,4])\n4-element Array{Int64,1}:\n 1\n 2\n 3\n 4  The  unique  function works faster when the input list comprises of sorted elements.", 
            "title": "Finding unique elements in the list"
        }, 
        {
            "location": "/arrays/setlike/#finding-elements-in-one-array-but-not-another", 
            "text": "To find the elements that are in one array, but not another, use  setdiff . For example:  julia  setdiff([1,2,3,4], [1,2,5,6])\n2-element Array{Int64,1}:\n 3\n 4  If your arrays have elements repeated, then use:  julia  filter(x -  !in(x, [1,2,4]), [1,2,2,3,3,4,6,7,7])\n5-element Array{Int64,1}:\n 3\n 3\n 6\n 7\n 7", 
            "title": "Finding Elements in One Array but Not Another"
        }, 
        {
            "location": "/arrays/setlike/#set-union", 
            "text": "The  union  function can be used to perform the set-union operation:  julia  union([1,2,3], [1,4,5])\n5-element Array{Int64,1}:\n 1\n 2\n 3\n 4\n 5", 
            "title": "Set union"
        }, 
        {
            "location": "/arrays/setlike/#set-intersection", 
            "text": "The  intersect  function can be used to perform the set-intersection operation:  julia  intersect([1,2,3,4], [1,2,3,5])\n3-element Array{Int64,1}:\n 1\n 2\n 3", 
            "title": "Set intersection"
        }, 
        {
            "location": "/arrays/search/", 
            "text": "Searching\n\n\n\n\nFinding the First List Element That Passes a Test\n\n\nThe \nfindfirst\n function can be used to find the position of the first non-zero element in an array:\n\n\njulia\n findfirst([0,0,1,2,0])\n3\n\n\n\n\nIt can also be used to find the first element equal to some value \nv\n.\n\n\njulia\n findfirst([0,0,1,2,0], 2)\n4\n\n\n\n\nFinally, a boolean-returning-function can be passed in as a \"test\". The position of the first element to pass the \"test\", (i.e. the function returns true) is returned:\n\n\njulia\n findfirst(x -\n x == 2, [0,0,1,2,0])\n4\n\n\n\n\nIf \nfindfirst\n cannot find a value, or if no element passes the \"test\", then it returns 0.\n\n\njulia\n findfirst([0,0,0])\n0\n\njulia\n findfirst([0,0,0], 1)\n0\n\n\n\n\n\n\nFinding All Elements in an Array Matching Certain Criteria\n\n\nThe \nfind\n function can be used to find the positions of all non-zero elements in an array.\n\n\njulia\n find([0,0,1,2,0])\n2-element Array{Int64,1}:\n 3\n 4\n\n\n\n\nThe \nfind\n function can also be used to find the positions of all elements that pass a \"test\", described by a boolean-returning-function.\n\n\njulia\n find(x -\n x == 0, [1,2,0,2,0,1,0])\n3-element Array{Int64,1}:\n 3\n 5\n 7\n\n\n\n\n\n\nFiltering out elements\n\n\nIf you'd like to remove the elements of an array that do not satisfy a condition, the \nfilter\n function can come in handy. For example, to remove the negative numbers in an array:\n\n\njulia\n filter(x -\n x \n= 0, [1,-2,3,-4,0])\n2-element Array{Int64,1}:\n 1\n 3\n 0", 
            "title": "Search"
        }, 
        {
            "location": "/arrays/search/#searching", 
            "text": "", 
            "title": "Searching"
        }, 
        {
            "location": "/arrays/search/#finding-the-first-list-element-that-passes-a-test", 
            "text": "The  findfirst  function can be used to find the position of the first non-zero element in an array:  julia  findfirst([0,0,1,2,0])\n3  It can also be used to find the first element equal to some value  v .  julia  findfirst([0,0,1,2,0], 2)\n4  Finally, a boolean-returning-function can be passed in as a \"test\". The position of the first element to pass the \"test\", (i.e. the function returns true) is returned:  julia  findfirst(x -  x == 2, [0,0,1,2,0])\n4  If  findfirst  cannot find a value, or if no element passes the \"test\", then it returns 0.  julia  findfirst([0,0,0])\n0\n\njulia  findfirst([0,0,0], 1)\n0", 
            "title": "Finding the First List Element That Passes a Test"
        }, 
        {
            "location": "/arrays/search/#finding-all-elements-in-an-array-matching-certain-criteria", 
            "text": "The  find  function can be used to find the positions of all non-zero elements in an array.  julia  find([0,0,1,2,0])\n2-element Array{Int64,1}:\n 3\n 4  The  find  function can also be used to find the positions of all elements that pass a \"test\", described by a boolean-returning-function.  julia  find(x -  x == 0, [1,2,0,2,0,1,0])\n3-element Array{Int64,1}:\n 3\n 5\n 7", 
            "title": "Finding All Elements in an Array Matching Certain Criteria"
        }, 
        {
            "location": "/arrays/search/#filtering-out-elements", 
            "text": "If you'd like to remove the elements of an array that do not satisfy a condition, the  filter  function can come in handy. For example, to remove the negative numbers in an array:  julia  filter(x -  x  = 0, [1,-2,3,-4,0])\n2-element Array{Int64,1}:\n 1\n 3\n 0", 
            "title": "Filtering out elements"
        }, 
        {
            "location": "/arrays/threed/", 
            "text": "Three dimensional arrays\n\n\nThis file contains an example demonstrating the use of three dimensional arrays.\n\n\nConsider the system of equations presented below:\n\n\nxrange = 1 : 0.1 : 10\nyrange = 1 : 0.1 : 10\nzrange = 1 : 0.1 : 10\n\na = 1\nb = 2\nc = 3\n\nf(x,y,z) = (x - a) * (y - b) * (z - c)\ng(x,y,z) = (x - a) ^ 2 + (y - b) ^ 2 + (z - c) ^ 2\n\n\n\n\nIf you want to cache the values of \nf\n and \ng\n for each (x,y,z), then you'd need a three dimensional array:\n\n\ntype Point\n   x::Float64\n   y::Float64\n   z::Float64\n   fv::Float64\n   gv::Float64\nend\n\ntype Cache\n   xrange::Range\n   yrange::Range\n   zrange::Range\n   points::Array{Point,3}\n\n   function Cache(xrange::Range, yrange::Range, zrange::Range, f::Function, g::Function)\n      self = new(xrange, yrange, zrange, Array{Point,3}(length(xrange), length(yrange), length(zrange)))\n\n      for (i,x) in enumerate(xrange), (j,y) in enumerate(yrange), (k,z) in enumerate(zrange)\n         self.points[i,j,k] = Point(x, y, z, f(x,y,z), g(x,y,z))\n      end\n      self\n   end\nend\n\nBase.show(io::IO, x::Cache) = write(io, \nThree dimensional points array with $(length(x.points)) values.\\n X = $(x.xrange)\\n Y = $(x.yrange)\\n Z = $(x.zrange)\\n\n)\n\njulia\n cache = Cache(xrange, yrange, zrange, f, g)\nThree dimensional points array with 753571 values.\n X = 1.0:0.1:10.0\n Y = 1.0:0.1:10.0\n Z = 1.0:0.1:10.0\n\n\n\n\nType \ncache\n stores the value of \nf(x,y,z) and g(x,y,z)\n for each \n(x,y,z)\n. But what if you wanted to access the closest available \nf\n value for some (x,y,z)? This would require you to define a \ngetindex\n method for type \ncache\n:\n\n\n\nwithin(i::Number, range::Range) =  minimum(range) \n= i \n= maximum(range)\n\nfunction Base.getindex(c::Cache, x::Float64, y::Float64, z::Float64)\n   i = within(x, c.xrange) ? searchsortedfirst(c.xrange, x) : error(\nX argument out of range\n)\n   j = within(y, c.yrange) ? searchsortedfirst(c.yrange, y) : error(\nY argument out of range\n)\n   k = within(z, c.zrange) ? searchsortedfirst(c.zrange, z) : error(\nZ argument out of range\n)\n\n   c.points[i,j,k]\nend\n\njulia\n cache[3.56, 7.90, 9.15]\nPoint(3.6,7.9,9.2,95.108,80.00999999999999)", 
            "title": "3D Arrays"
        }, 
        {
            "location": "/arrays/threed/#three-dimensional-arrays", 
            "text": "This file contains an example demonstrating the use of three dimensional arrays.  Consider the system of equations presented below:  xrange = 1 : 0.1 : 10\nyrange = 1 : 0.1 : 10\nzrange = 1 : 0.1 : 10\n\na = 1\nb = 2\nc = 3\n\nf(x,y,z) = (x - a) * (y - b) * (z - c)\ng(x,y,z) = (x - a) ^ 2 + (y - b) ^ 2 + (z - c) ^ 2  If you want to cache the values of  f  and  g  for each (x,y,z), then you'd need a three dimensional array:  type Point\n   x::Float64\n   y::Float64\n   z::Float64\n   fv::Float64\n   gv::Float64\nend\n\ntype Cache\n   xrange::Range\n   yrange::Range\n   zrange::Range\n   points::Array{Point,3}\n\n   function Cache(xrange::Range, yrange::Range, zrange::Range, f::Function, g::Function)\n      self = new(xrange, yrange, zrange, Array{Point,3}(length(xrange), length(yrange), length(zrange)))\n\n      for (i,x) in enumerate(xrange), (j,y) in enumerate(yrange), (k,z) in enumerate(zrange)\n         self.points[i,j,k] = Point(x, y, z, f(x,y,z), g(x,y,z))\n      end\n      self\n   end\nend\n\nBase.show(io::IO, x::Cache) = write(io,  Three dimensional points array with $(length(x.points)) values.\\n X = $(x.xrange)\\n Y = $(x.yrange)\\n Z = $(x.zrange)\\n )\n\njulia  cache = Cache(xrange, yrange, zrange, f, g)\nThree dimensional points array with 753571 values.\n X = 1.0:0.1:10.0\n Y = 1.0:0.1:10.0\n Z = 1.0:0.1:10.0  Type  cache  stores the value of  f(x,y,z) and g(x,y,z)  for each  (x,y,z) . But what if you wanted to access the closest available  f  value for some (x,y,z)? This would require you to define a  getindex  method for type  cache :  \nwithin(i::Number, range::Range) =  minimum(range)  = i  = maximum(range)\n\nfunction Base.getindex(c::Cache, x::Float64, y::Float64, z::Float64)\n   i = within(x, c.xrange) ? searchsortedfirst(c.xrange, x) : error( X argument out of range )\n   j = within(y, c.yrange) ? searchsortedfirst(c.yrange, y) : error( Y argument out of range )\n   k = within(z, c.zrange) ? searchsortedfirst(c.zrange, z) : error( Z argument out of range )\n\n   c.points[i,j,k]\nend\n\njulia  cache[3.56, 7.90, 9.15]\nPoint(3.6,7.9,9.2,95.108,80.00999999999999)", 
            "title": "Three dimensional arrays"
        }, 
        {
            "location": "/dates/", 
            "text": "Date-Time\n\n\nJulia provides the immutable \nDate\n and \nDateTime\n data structures for working with dates. The \nDate\n object stores only a date and can be created as:\n\n\nDate(YEAR, MONTH, DAY)\n\njulia\n Date(2016, 9, 26)\n2016-09-26\n\n\n\n\nAlternatively a format string can be passed in for a custom date string:\n\n\njulia\n Date(\n26/09/2016\n, \ndd/mm/yyyy\n)\n2016-09-26\n\njulia\n Date(\n09-26-2016\n, \nmm-dd-yyyy\n)\n2016-09-26\n\n\n\n\nThe \nDateTime\n object can be used to work with both date and time, and accepts a variable number of arguments:\n\n\nDateTime([YEAR], [MONTH], [DAY], [HOURS], [MINUTES], [SECONDS], [MILLI SECONDS])\n\njulia\n DateTime(2016)\n2016-01-01T00:00:00\n\njulia\n DateTime(2016, 09, 26, 5, 30)\n2016-09-26T05:30:00\n\n\n\n\nThe \nDateTime\n function also accepts a format string for date strings:\n\n\njulia\n DateTime(\n20160926 173000\n,\nyyyymmdd HHMMSS\n)\n2016-09-26T17:30:00\n\n\n\n\n\n\nFinding Today's Date\n\n\nTo fetch a \nDate\n object containing the current date:\n\n\njulia\n Dates.today()\n2016-09-26\n\n\n\n\nTo fetch a \nDateTime\n object containing the current date and time:\n\n\njulia\n Dates.now()\n2016-09-26T18:56:04.868\n\n\n\n\n\n\nAccessing Date-Time fields\n\n\nJulia provides functions to access the individual fields in a \nDateTime\n or \nDate\n object:\n\n\njulia\n using Dates\n\njulia\n t = DateTime(2016, 9, 26, 17, 30, 0)\n2016-09-26T17:30:00\n\njulia\n Dates.year(t)\n2016\n\njulia\n Dates.month(t)\n9\n\njulia\n Dates.day(t)\n26\n\njulia\n Dates.hour(t)\n17\n\njulia\n Dates.minute(t)\n30\n\njulia\n Dates.second(t)\n0\n\n\n\n\n\n\nConverting a Date-Time object to Epoch seconds\n\n\nJulia provides the \ndatetime2epochms\n function to convert the date denoted by a \nDateTime\n object into the number of seconds elapsed since the rounding epoch date-time \n0000-01-01T00:00:00\n:\n\n\njulia\n Dates.datetime2epochms(Dates.now())\n63642136200066\n\n\n\n\n\n\nConverting Epoch Seconds to a Date-Time object\n\n\nJulia provides the \nepochms2datetime\n function to convert the date denoted by the number of milliseconds elapsed since the rounding epoch date-time, into a \nDateTime\n object:\n\n\njulia\n Dates.epochms2datetime(63642136200066)\n2016-09-26T19:10:00.066\n\n\n\n\n\n\nAdding to or Subtracting from a Date\n\n\nDate\n objects can be subtracted to yield a result in days:\n\n\njulia\n Date(2016, 09, 26) - Date(2016, 07, 13)\n75 days\n\n\n\n\nSimilarly, \nDateTime\n objects can be subtracted to yield a result in milliseconds:\n\n\njulia\n DateTime(2016, 09, 26, 5, 20, 26) - DateTime(2016, 07, 13, 11, 19)\n6458486000 milliseconds\n\n\n\n\nAdditionally, individual \nDateTime\n components can be added or subtracted from both \nDate\n and \nDateTime\n objects, to yield new objects:\n\n\njulia\n Date(2016, 09, 26) - Dates.Year(1) + Dates.Day(10)\n2015-10-06\n\njulia\n DateTime(2016, 09, 26, 5, 20, 26) - Dates.Month(2) + Dates.Hour(3) - Dates.Second(10)\n2016-07-26T08:20:16\n\n\n\n\n\n\nDay in a Week/Month/Year or Week Number\n\n\nJulia provides query functions for \nDateTime\n objects:\n\n\njulia\n t = Dates.now()\n2016-09-26T19:25:01.028\n\njulia\n Dates.dayofweek(t)\n1\n\njulia\n Dates.dayofmonth(t)\n26\n\njulia\n Dates.dayofyear(t)\n270\n\njulia\n Dates.week(t)\n39", 
            "title": "Dates"
        }, 
        {
            "location": "/dates/#date-time", 
            "text": "Julia provides the immutable  Date  and  DateTime  data structures for working with dates. The  Date  object stores only a date and can be created as:  Date(YEAR, MONTH, DAY)\n\njulia  Date(2016, 9, 26)\n2016-09-26  Alternatively a format string can be passed in for a custom date string:  julia  Date( 26/09/2016 ,  dd/mm/yyyy )\n2016-09-26\n\njulia  Date( 09-26-2016 ,  mm-dd-yyyy )\n2016-09-26  The  DateTime  object can be used to work with both date and time, and accepts a variable number of arguments:  DateTime([YEAR], [MONTH], [DAY], [HOURS], [MINUTES], [SECONDS], [MILLI SECONDS])\n\njulia  DateTime(2016)\n2016-01-01T00:00:00\n\njulia  DateTime(2016, 09, 26, 5, 30)\n2016-09-26T05:30:00  The  DateTime  function also accepts a format string for date strings:  julia  DateTime( 20160926 173000 , yyyymmdd HHMMSS )\n2016-09-26T17:30:00", 
            "title": "Date-Time"
        }, 
        {
            "location": "/dates/#finding-todays-date", 
            "text": "To fetch a  Date  object containing the current date:  julia  Dates.today()\n2016-09-26  To fetch a  DateTime  object containing the current date and time:  julia  Dates.now()\n2016-09-26T18:56:04.868", 
            "title": "Finding Today's Date"
        }, 
        {
            "location": "/dates/#accessing-date-time-fields", 
            "text": "Julia provides functions to access the individual fields in a  DateTime  or  Date  object:  julia  using Dates\n\njulia  t = DateTime(2016, 9, 26, 17, 30, 0)\n2016-09-26T17:30:00\n\njulia  Dates.year(t)\n2016\n\njulia  Dates.month(t)\n9\n\njulia  Dates.day(t)\n26\n\njulia  Dates.hour(t)\n17\n\njulia  Dates.minute(t)\n30\n\njulia  Dates.second(t)\n0", 
            "title": "Accessing Date-Time fields"
        }, 
        {
            "location": "/dates/#converting-a-date-time-object-to-epoch-seconds", 
            "text": "Julia provides the  datetime2epochms  function to convert the date denoted by a  DateTime  object into the number of seconds elapsed since the rounding epoch date-time  0000-01-01T00:00:00 :  julia  Dates.datetime2epochms(Dates.now())\n63642136200066", 
            "title": "Converting a Date-Time object to Epoch seconds"
        }, 
        {
            "location": "/dates/#converting-epoch-seconds-to-a-date-time-object", 
            "text": "Julia provides the  epochms2datetime  function to convert the date denoted by the number of milliseconds elapsed since the rounding epoch date-time, into a  DateTime  object:  julia  Dates.epochms2datetime(63642136200066)\n2016-09-26T19:10:00.066", 
            "title": "Converting Epoch Seconds to a Date-Time object"
        }, 
        {
            "location": "/dates/#adding-to-or-subtracting-from-a-date", 
            "text": "Date  objects can be subtracted to yield a result in days:  julia  Date(2016, 09, 26) - Date(2016, 07, 13)\n75 days  Similarly,  DateTime  objects can be subtracted to yield a result in milliseconds:  julia  DateTime(2016, 09, 26, 5, 20, 26) - DateTime(2016, 07, 13, 11, 19)\n6458486000 milliseconds  Additionally, individual  DateTime  components can be added or subtracted from both  Date  and  DateTime  objects, to yield new objects:  julia  Date(2016, 09, 26) - Dates.Year(1) + Dates.Day(10)\n2015-10-06\n\njulia  DateTime(2016, 09, 26, 5, 20, 26) - Dates.Month(2) + Dates.Hour(3) - Dates.Second(10)\n2016-07-26T08:20:16", 
            "title": "Adding to or Subtracting from a Date"
        }, 
        {
            "location": "/dates/#day-in-a-weekmonthyear-or-week-number", 
            "text": "Julia provides query functions for  DateTime  objects:  julia  t = Dates.now()\n2016-09-26T19:25:01.028\n\njulia  Dates.dayofweek(t)\n1\n\njulia  Dates.dayofmonth(t)\n26\n\njulia  Dates.dayofyear(t)\n270\n\njulia  Dates.week(t)\n39", 
            "title": "Day in a Week/Month/Year or Week Number"
        }, 
        {
            "location": "/regex/", 
            "text": "Pattern Matching\n\n\nJulia supports regular expressions or regexes for string matching. The expressions must be compliant with the \nPerl Compatible Regular Expressions\n library.\n\n\nA regular expression in Julia is denoted by a leading \nr\n. For example, a regular to match comments will look like:\n\n\nr\n^\\s*(?:#|$)\n\n\n\n\n\nThe \nismatch\n, \nmatch\n and \nreplace\n functions accept regular expressions.\n\n\n\n\nMatching Letters\n\n\nTo check if a string consists of only alphabetic characters:\n\n\njulia\n ismatch(r\n^[A-Za-z]*$\n, \nasdf\n)\ntrue\n\njulia\n ismatch(r\n^[A-Za-z]*$\n, \nasdf123\n)\nfalse\n\n\n\n\n\n\nMatching Words\n\n\nUse the \n\\b\n character to match at word boundaries.\n\n\njulia\n match(r\n\\bthe\\b\n, \nread the thesaurus\n).offset\n6\n\n\n\n\n\n\nFinding the nth match\n\n\nThe \nmatchall\n function can be used to return all occurrences of a pattern in a string. To nth match can then be retrieved using an indexing. For example, to find the third integer in a string:\n\n\njulia\n matchall(r\n[0-9]+\n, \n12 apples plus 1 make 13\n)[3]\n\n13\n\n\n\n\n\nHowever, for larger strings, it may take a while to generate all matches. For such cases:\n\n\nfunction nth_occurance(pattern::Regex, n::Int, str::String)\n   count = 1\n   idx = 1\n   while idx \n= length(str)\n      m = match(pattern, str, idx)\n      if m == nothing\n         return\n      elseif(count == n)\n         return m.match\n      else\n         count += 1\n         idx = m.offset + length(m.match) + 1\n      end\n   end\n\n   return\nend\n\njulia\n nth_occurance(r\n[0-9]+\n, 3, \n12 plus 1 make 13\n)\n\n13", 
            "title": "Regex"
        }, 
        {
            "location": "/regex/#pattern-matching", 
            "text": "Julia supports regular expressions or regexes for string matching. The expressions must be compliant with the  Perl Compatible Regular Expressions  library.  A regular expression in Julia is denoted by a leading  r . For example, a regular to match comments will look like:  r ^\\s*(?:#|$)   The  ismatch ,  match  and  replace  functions accept regular expressions.", 
            "title": "Pattern Matching"
        }, 
        {
            "location": "/regex/#matching-letters", 
            "text": "To check if a string consists of only alphabetic characters:  julia  ismatch(r ^[A-Za-z]*$ ,  asdf )\ntrue\n\njulia  ismatch(r ^[A-Za-z]*$ ,  asdf123 )\nfalse", 
            "title": "Matching Letters"
        }, 
        {
            "location": "/regex/#matching-words", 
            "text": "Use the  \\b  character to match at word boundaries.  julia  match(r \\bthe\\b ,  read the thesaurus ).offset\n6", 
            "title": "Matching Words"
        }, 
        {
            "location": "/regex/#finding-the-nth-match", 
            "text": "The  matchall  function can be used to return all occurrences of a pattern in a string. To nth match can then be retrieved using an indexing. For example, to find the third integer in a string:  julia  matchall(r [0-9]+ ,  12 apples plus 1 make 13 )[3] 13   However, for larger strings, it may take a while to generate all matches. For such cases:  function nth_occurance(pattern::Regex, n::Int, str::String)\n   count = 1\n   idx = 1\n   while idx  = length(str)\n      m = match(pattern, str, idx)\n      if m == nothing\n         return\n      elseif(count == n)\n         return m.match\n      else\n         count += 1\n         idx = m.offset + length(m.match) + 1\n      end\n   end\n\n   return\nend\n\njulia  nth_occurance(r [0-9]+ , 3,  12 plus 1 make 13 ) 13", 
            "title": "Finding the nth match"
        }, 
        {
            "location": "/dates/", 
            "text": "Date-Time\n\n\nJulia provides the immutable \nDate\n and \nDateTime\n data structures for working with dates. The \nDate\n object stores only a date and can be created as:\n\n\nDate(YEAR, MONTH, DAY)\n\njulia\n Date(2016, 9, 26)\n2016-09-26\n\n\n\n\nAlternatively a format string can be passed in for a custom date string:\n\n\njulia\n Date(\n26/09/2016\n, \ndd/mm/yyyy\n)\n2016-09-26\n\njulia\n Date(\n09-26-2016\n, \nmm-dd-yyyy\n)\n2016-09-26\n\n\n\n\nThe \nDateTime\n object can be used to work with both date and time, and accepts a variable number of arguments:\n\n\nDateTime([YEAR], [MONTH], [DAY], [HOURS], [MINUTES], [SECONDS], [MILLI SECONDS])\n\njulia\n DateTime(2016)\n2016-01-01T00:00:00\n\njulia\n DateTime(2016, 09, 26, 5, 30)\n2016-09-26T05:30:00\n\n\n\n\nThe \nDateTime\n function also accepts a format string for date strings:\n\n\njulia\n DateTime(\n20160926 173000\n,\nyyyymmdd HHMMSS\n)\n2016-09-26T17:30:00\n\n\n\n\n\n\nFinding Today's Date\n\n\nTo fetch a \nDate\n object containing the current date:\n\n\njulia\n Dates.today()\n2016-09-26\n\n\n\n\nTo fetch a \nDateTime\n object containing the current date and time:\n\n\njulia\n Dates.now()\n2016-09-26T18:56:04.868\n\n\n\n\n\n\nAccessing Date-Time fields\n\n\nJulia provides functions to access the individual fields in a \nDateTime\n or \nDate\n object:\n\n\njulia\n using Dates\n\njulia\n t = DateTime(2016, 9, 26, 17, 30, 0)\n2016-09-26T17:30:00\n\njulia\n Dates.year(t)\n2016\n\njulia\n Dates.month(t)\n9\n\njulia\n Dates.day(t)\n26\n\njulia\n Dates.hour(t)\n17\n\njulia\n Dates.minute(t)\n30\n\njulia\n Dates.second(t)\n0\n\n\n\n\n\n\nConverting a Date-Time object to Epoch seconds\n\n\nJulia provides the \ndatetime2epochms\n function to convert the date denoted by a \nDateTime\n object into the number of seconds elapsed since the rounding epoch date-time \n0000-01-01T00:00:00\n:\n\n\njulia\n Dates.datetime2epochms(Dates.now())\n63642136200066\n\n\n\n\n\n\nConverting Epoch Seconds to a Date-Time object\n\n\nJulia provides the \nepochms2datetime\n function to convert the date denoted by the number of milliseconds elapsed since the rounding epoch date-time, into a \nDateTime\n object:\n\n\njulia\n Dates.epochms2datetime(63642136200066)\n2016-09-26T19:10:00.066\n\n\n\n\n\n\nAdding to or Subtracting from a Date\n\n\nDate\n objects can be subtracted to yield a result in days:\n\n\njulia\n Date(2016, 09, 26) - Date(2016, 07, 13)\n75 days\n\n\n\n\nSimilarly, \nDateTime\n objects can be subtracted to yield a result in milliseconds:\n\n\njulia\n DateTime(2016, 09, 26, 5, 20, 26) - DateTime(2016, 07, 13, 11, 19)\n6458486000 milliseconds\n\n\n\n\nAdditionally, individual \nDateTime\n components can be added or subtracted from both \nDate\n and \nDateTime\n objects, to yield new objects:\n\n\njulia\n Date(2016, 09, 26) - Dates.Year(1) + Dates.Day(10)\n2015-10-06\n\njulia\n DateTime(2016, 09, 26, 5, 20, 26) - Dates.Month(2) + Dates.Hour(3) - Dates.Second(10)\n2016-07-26T08:20:16\n\n\n\n\n\n\nDay in a Week/Month/Year or Week Number\n\n\nJulia provides query functions for \nDateTime\n objects:\n\n\njulia\n t = Dates.now()\n2016-09-26T19:25:01.028\n\njulia\n Dates.dayofweek(t)\n1\n\njulia\n Dates.dayofmonth(t)\n26\n\njulia\n Dates.dayofyear(t)\n270\n\njulia\n Dates.week(t)\n39", 
            "title": "Dates"
        }, 
        {
            "location": "/dates/#date-time", 
            "text": "Julia provides the immutable  Date  and  DateTime  data structures for working with dates. The  Date  object stores only a date and can be created as:  Date(YEAR, MONTH, DAY)\n\njulia  Date(2016, 9, 26)\n2016-09-26  Alternatively a format string can be passed in for a custom date string:  julia  Date( 26/09/2016 ,  dd/mm/yyyy )\n2016-09-26\n\njulia  Date( 09-26-2016 ,  mm-dd-yyyy )\n2016-09-26  The  DateTime  object can be used to work with both date and time, and accepts a variable number of arguments:  DateTime([YEAR], [MONTH], [DAY], [HOURS], [MINUTES], [SECONDS], [MILLI SECONDS])\n\njulia  DateTime(2016)\n2016-01-01T00:00:00\n\njulia  DateTime(2016, 09, 26, 5, 30)\n2016-09-26T05:30:00  The  DateTime  function also accepts a format string for date strings:  julia  DateTime( 20160926 173000 , yyyymmdd HHMMSS )\n2016-09-26T17:30:00", 
            "title": "Date-Time"
        }, 
        {
            "location": "/dates/#finding-todays-date", 
            "text": "To fetch a  Date  object containing the current date:  julia  Dates.today()\n2016-09-26  To fetch a  DateTime  object containing the current date and time:  julia  Dates.now()\n2016-09-26T18:56:04.868", 
            "title": "Finding Today's Date"
        }, 
        {
            "location": "/dates/#accessing-date-time-fields", 
            "text": "Julia provides functions to access the individual fields in a  DateTime  or  Date  object:  julia  using Dates\n\njulia  t = DateTime(2016, 9, 26, 17, 30, 0)\n2016-09-26T17:30:00\n\njulia  Dates.year(t)\n2016\n\njulia  Dates.month(t)\n9\n\njulia  Dates.day(t)\n26\n\njulia  Dates.hour(t)\n17\n\njulia  Dates.minute(t)\n30\n\njulia  Dates.second(t)\n0", 
            "title": "Accessing Date-Time fields"
        }, 
        {
            "location": "/dates/#converting-a-date-time-object-to-epoch-seconds", 
            "text": "Julia provides the  datetime2epochms  function to convert the date denoted by a  DateTime  object into the number of seconds elapsed since the rounding epoch date-time  0000-01-01T00:00:00 :  julia  Dates.datetime2epochms(Dates.now())\n63642136200066", 
            "title": "Converting a Date-Time object to Epoch seconds"
        }, 
        {
            "location": "/dates/#converting-epoch-seconds-to-a-date-time-object", 
            "text": "Julia provides the  epochms2datetime  function to convert the date denoted by the number of milliseconds elapsed since the rounding epoch date-time, into a  DateTime  object:  julia  Dates.epochms2datetime(63642136200066)\n2016-09-26T19:10:00.066", 
            "title": "Converting Epoch Seconds to a Date-Time object"
        }, 
        {
            "location": "/dates/#adding-to-or-subtracting-from-a-date", 
            "text": "Date  objects can be subtracted to yield a result in days:  julia  Date(2016, 09, 26) - Date(2016, 07, 13)\n75 days  Similarly,  DateTime  objects can be subtracted to yield a result in milliseconds:  julia  DateTime(2016, 09, 26, 5, 20, 26) - DateTime(2016, 07, 13, 11, 19)\n6458486000 milliseconds  Additionally, individual  DateTime  components can be added or subtracted from both  Date  and  DateTime  objects, to yield new objects:  julia  Date(2016, 09, 26) - Dates.Year(1) + Dates.Day(10)\n2015-10-06\n\njulia  DateTime(2016, 09, 26, 5, 20, 26) - Dates.Month(2) + Dates.Hour(3) - Dates.Second(10)\n2016-07-26T08:20:16", 
            "title": "Adding to or Subtracting from a Date"
        }, 
        {
            "location": "/dates/#day-in-a-weekmonthyear-or-week-number", 
            "text": "Julia provides query functions for  DateTime  objects:  julia  t = Dates.now()\n2016-09-26T19:25:01.028\n\njulia  Dates.dayofweek(t)\n1\n\njulia  Dates.dayofmonth(t)\n26\n\njulia  Dates.dayofyear(t)\n270\n\njulia  Dates.week(t)\n39", 
            "title": "Day in a Week/Month/Year or Week Number"
        }, 
        {
            "location": "/dataframes/DataFrames/", 
            "text": "DataFrames Recipes\n\n\nThis folder contains concrete examples for getting started with \nDataFrames\n in Julia. Efforts have been made to match the use cases in popular DataFrames cookbooks for other languages, such as the \nPandas\n cookbook for Python.\n\n\nThe \nRDatasets\n repository is introduced as a collection of R datatests, and \nGLM.jl\n (Generalized Linear Models) is used for Linear Regressions. Plotting is accomplished using \nPlots.jl\n.\n\n\nCompressed files are read using \nGZip.jl\n.\n\n\n\n\nRequired Packages\n\n\n\njulia\n Pkg.add(\nDataFrames\n)\njulia\n Pkg.add(\nRDatasets\n)\njulia\n Pkg.add(\nPyPlot\n)\njulia\n Pkg.add(\nGLM\n)\njulia\n Pkg.add(\nGZip\n)\n\n\n\n\n\n\nLoading Packages\n\n\njulia\n using DataFrames\njulia\n using RDatasets\njulia\n using PyPlot\njulia\n using GLM\njulia\n using GZip\n\n\n\n\n\n\nContents\n\n\n\n\nReading from Files\n\n\nAccessing Data\n\n\nRDatasets\n\n\nPlotting\n\n\nRegressions\n\n\n\n\n\n\nReferences\n\n\n\n\nDataFrames.jl documentation\n\n\nDataFrames.jl Wiki\n\n\nRDatasets.jl\n\n\nPlots.jl documentation\n\n\nGLM.jl\n\n\nGZip.jl", 
            "title": "Introduction"
        }, 
        {
            "location": "/dataframes/DataFrames/#dataframes-recipes", 
            "text": "This folder contains concrete examples for getting started with  DataFrames  in Julia. Efforts have been made to match the use cases in popular DataFrames cookbooks for other languages, such as the  Pandas  cookbook for Python.  The  RDatasets  repository is introduced as a collection of R datatests, and  GLM.jl  (Generalized Linear Models) is used for Linear Regressions. Plotting is accomplished using  Plots.jl .  Compressed files are read using  GZip.jl .", 
            "title": "DataFrames Recipes"
        }, 
        {
            "location": "/dataframes/DataFrames/#required-packages", 
            "text": "julia  Pkg.add( DataFrames )\njulia  Pkg.add( RDatasets )\njulia  Pkg.add( PyPlot )\njulia  Pkg.add( GLM )\njulia  Pkg.add( GZip )", 
            "title": "Required Packages"
        }, 
        {
            "location": "/dataframes/DataFrames/#loading-packages", 
            "text": "julia  using DataFrames\njulia  using RDatasets\njulia  using PyPlot\njulia  using GLM\njulia  using GZip", 
            "title": "Loading Packages"
        }, 
        {
            "location": "/dataframes/DataFrames/#contents", 
            "text": "Reading from Files  Accessing Data  RDatasets  Plotting  Regressions", 
            "title": "Contents"
        }, 
        {
            "location": "/dataframes/DataFrames/#references", 
            "text": "DataFrames.jl documentation  DataFrames.jl Wiki  RDatasets.jl  Plots.jl documentation  GLM.jl  GZip.jl", 
            "title": "References"
        }, 
        {
            "location": "/dataframes/file_input/", 
            "text": "Reading Delimiter-Separated data\n\n\nThe \nreadtable\n function from \nDataFrames.jl\n can be used to read the contents of a \nCSV/TSV/WSV\n file into a DataFrame. A call to \nreadtable\n typically looks like:\n\n\nreadtable(\nFILENAME\n; [KEYWORD_ARGS]...)\n\n\n\n\nSome of the keyword arguments, described in the \nreadtable\n docstring, are:\n\n\n\n\nheader::Bool=true\n \u2013 Use the information from the file's header line to determine column names.\n\n\nseparator::Char\n \u2013 Assume that fields are split by the separator character. If not specified, it will be guessed from the filename.\n\n\nallowcomments::Bool=false\n \u2013 Ignore all text inside comments. Defaults to false.\n\n\nskipblanks::Bool=true\n \u2013 Skip any blank lines in input. Defaults to true.\n\n\n\n\nYou can see the entire list of keyword arguments using:\n\n\njulia\n ?readtable\n\n\n\n\nSince the dataset has commented lines, we set the \nallowcomments\n argument to \ntrue\n.\n\n\njulia\n filename = joinpath(Pkg.dir(\nJuliaCookbook\n), \ndatasets\n, \nbaseball_players.tsv\n) # Locate the dataset\njulia\n df = readtable(filename; allowcomments=true)                                      # Read the DataFrame\n1033\u00d76 DataFrames.DataFrame\n\u2502 Row  \u2502 Name                 \u2502 Team  \u2502 Position            \u2502 Height_inches_ \u2502 Weight_pounds_ \u2502 Age   \u2502\n\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\n\u2502 1    \u2502 \nAdam_Donachie\n      \u2502 \nBAL\n \u2502 \nCatcher\n           \u2502 74             \u2502 180            \u2502 22.99 \u2502\n\u2502 2    \u2502 \nPaul_Bako\n          \u2502 \nBAL\n \u2502 \nCatcher\n           \u2502 74             \u2502 215            \u2502 34.69 \u2502\n\u2502 3    \u2502 \nRamon_Hernandez\n    \u2502 \nBAL\n \u2502 \nCatcher\n           \u2502 72             \u2502 210            \u2502 30.78 \u2502\n\u2502 4    \u2502 \nKevin_Millar\n       \u2502 \nBAL\n \u2502 \nFirst_Baseman\n     \u2502 72             \u2502 210            \u2502 35.43 \u2502\n\u2502 5    \u2502 \nChris_Gomez\n        \u2502 \nBAL\n \u2502 \nFirst_Baseman\n     \u2502 73             \u2502 188            \u2502 35.71 \u2502\n\u2502 6    \u2502 \nBrian_Roberts\n      \u2502 \nBAL\n \u2502 \nSecond_Baseman\n    \u2502 69             \u2502 176            \u2502 29.39 \u2502\n\u2502 7    \u2502 \nMiguel_Tejada\n      \u2502 \nBAL\n \u2502 \nShortstop\n         \u2502 69             \u2502 209            \u2502 30.77 \u2502\n\u2502 8    \u2502 \nMelvin_Mora\n        \u2502 \nBAL\n \u2502 \nThird_Baseman\n     \u2502 71             \u2502 200            \u2502 35.07 \u2502\n\u2502 9    \u2502 \nAubrey_Huff\n        \u2502 \nBAL\n \u2502 \nThird_Baseman\n     \u2502 76             \u2502 231            \u2502 30.19 \u2502\n\u2502 10   \u2502 \nAdam_Stern\n         \u2502 \nBAL\n \u2502 \nOutfielder\n        \u2502 71             \u2502 180            \u2502 27.05 \u2502\n\u22ee\n\u2502 1025 \u2502 \nJason_Isringhausen\n \u2502 \nSTL\n \u2502 \nRelief_Pitcher\n    \u2502 75             \u2502 230            \u2502 34.48 \u2502\n\u2502 1026 \u2502 \nRicardo_Rincon\n     \u2502 \nSTL\n \u2502 \nRelief_Pitcher\n    \u2502 69             \u2502 190            \u2502 36.88 \u2502\n\u2502 1027 \u2502 \nBraden_Looper\n      \u2502 \nSTL\n \u2502 \nRelief_Pitcher\n    \u2502 75             \u2502 220            \u2502 32.34 \u2502\n\u2502 1028 \u2502 \nRandy_Flores\n       \u2502 \nSTL\n \u2502 \nRelief_Pitcher\n    \u2502 72             \u2502 180            \u2502 31.58 \u2502\n\u2502 1029 \u2502 \nJosh_Hancock\n       \u2502 \nSTL\n \u2502 \nRelief_Pitcher\n    \u2502 75             \u2502 205            \u2502 28.89 \u2502\n\u2502 1030 \u2502 \nBrad_Thompson\n      \u2502 \nSTL\n \u2502 \nRelief_Pitcher\n    \u2502 73             \u2502 190            \u2502 25.08 \u2502\n\u2502 1031 \u2502 \nTyler_Johnson\n      \u2502 \nSTL\n \u2502 \nRelief_Pitcher\n    \u2502 74             \u2502 180            \u2502 25.73 \u2502\n\u2502 1032 \u2502 \nChris_Narveson\n     \u2502 \nSTL\n \u2502 \nRelief_Pitcher\n    \u2502 75             \u2502 205            \u2502 25.19 \u2502\n\u2502 1033 \u2502 \nRandy_Keisler\n      \u2502 \nSTL\n \u2502 \nRelief_Pitcher\n    \u2502 75             \u2502 190            \u2502 31.01 \u2502\n\u2502 1034 \u2502 \nJosh_Kinney\n        \u2502 \nSTL\n \u2502 \nRelief_Pitcher\n    \u2502 73             \u2502 195            \u2502 27.92 \u2502\n\n\n\n\n\n\nHandling different comment marks\n\n\nThe \nreadtable\n function assumes that comment lines begin with the '#' character. Therefore, the default \nreadtable\n invocation looks like:\n\n\njulia\n readtable(\nFILE_NAME\n; allowcomments=true, commentmark='#')\n\n\n\n\nIf your dataset uses a different character to indicate commented lines, specify the character using the \ncommentmark\n keyword argument. For example, if your dataset uses the \n%\n character:\n\n\njulia\n readtable(\nFILE_NAME\n; allowcomments=true, commentmark='%')\n\n\n\n\n\n\nMultiple missing value strings\n\n\nBy default, \nreadtable\n translates the strings \n\"\"\n and \n\"NA\"\n into null values or \nNA\ns. If your dataset uses different or additional strings to represent null values, you can set the \nnastrings\n keyword argument to these strings. For example, if your dataset contains \n\"null\"\n, \n\"NULL\"\n and \n\"-\"\n to indicate null values, then run:\n\n\njulia\n readtable(\nFILE_NAME\n; nastrings=[\nnull\n, \nNULL\n, \n-\n])\n\n\n\n\n\n\nReading a subset of rows\n\n\nBy default, \nreadtable\n reads the entire file into a dataframe. Therefore, the default \nreadtable\n invocation looks like:\n\n\njulia\n readtable(\nFILE_NAME\n; nrows=-1)\n\n\n\n\nIf you're interested in the first few lines or don't want to overwhelm your memory, specify the number of rows you want to read with the \nnrows\n keyword argument. For example, to read the first 500 lines:\n\n\njulia\n readtable(\nFILE_NAME\n; nrows=500)\n\n\n\n\nIf you want to skip the first few lines, set the \nskipstart\n keyword argument. For example to skip the first 500 lines:\n\n\njulia\n readtable(\nFILE_NAME\n; skipstart=500)\n\n\n\n\nTo skip specific lines in the file, set the \nskiprows\n keyword argument to an array containing the rows you want to skip. For example to skip rows \n[10, 50, 100]\n:\n\n\njulia\n readtable(\nFILE_NAME\n; skiplines=[10, 50, 100])\n\n\n\n\nA complex combination of lines can be read by using one or more of \nnrows\n, \nskipstart\n and \nskiprows\n.\n\n\n\n\nReading from compressed files\n\n\nThe GZip package can be used to read \nDataFrame\ns from compressed files. The general syntax to do this is:\n\n\njulia\n GZip.open(\nFILE_NAME.gz\n) do f\n           readtable(f; [KEYWORD_ARGS]...)\n       end\n\n\n\n\nTo read a compressed version of the baseball players dataset:\n\n\njulia\n filename = joinpath(Pkg.dir(\nJuliaCookbook\n), \ndatasets\n, \nbaseball_players.tsv.gz\n) # Locate the dataset\njulia\n GZip.open(filename) do f\n           readtable(f; allowcomments=true, separator='\\t')\n       end\n1034\u00d76 DataFrames.DataFrame\n\u2502 Row  \u2502 Name                 \u2502 Team  \u2502 Position            \u2502 Height_inches_ \u2502 Weight_pounds_ \u2502 Age   \u2502\n\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\n\u2502 1    \u2502 \nAdam_Donachie\n      \u2502 \nBAL\n \u2502 \nCatcher\n           \u2502 74             \u2502 180            \u2502 22.99 \u2502\n\u2502 2    \u2502 \nPaul_Bako\n          \u2502 \nBAL\n \u2502 \nCatcher\n           \u2502 74             \u2502 215            \u2502 34.69 \u2502\n\u2502 3    \u2502 \nRamon_Hernandez\n    \u2502 \nBAL\n \u2502 \nCatcher\n           \u2502 72             \u2502 210            \u2502 30.78 \u2502\n\u2502 4    \u2502 \nKevin_Millar\n       \u2502 \nBAL\n \u2502 \nFirst_Baseman\n     \u2502 72             \u2502 210            \u2502 35.43 \u2502\n\u2502 5    \u2502 \nChris_Gomez\n        \u2502 \nBAL\n \u2502 \nFirst_Baseman\n     \u2502 73             \u2502 188            \u2502 35.71 \u2502\n  \u22ee\n\u2502 1030 \u2502 \nBrad_Thompson\n      \u2502 \nSTL\n \u2502 \nRelief_Pitcher\n    \u2502 73             \u2502 190            \u2502 25.08 \u2502\n\u2502 1031 \u2502 \nTyler_Johnson\n      \u2502 \nSTL\n \u2502 \nRelief_Pitcher\n    \u2502 74             \u2502 180            \u2502 25.73 \u2502\n\u2502 1032 \u2502 \nChris_Narveson\n     \u2502 \nSTL\n \u2502 \nRelief_Pitcher\n    \u2502 75             \u2502 205            \u2502 25.19 \u2502\n\u2502 1033 \u2502 \nRandy_Keisler\n      \u2502 \nSTL\n \u2502 \nRelief_Pitcher\n    \u2502 75             \u2502 190            \u2502 31.01 \u2502\n\u2502 1034 \u2502 \nJosh_Kinney\n        \u2502 \nSTL\n \u2502 \nRelief_Pitcher\n    \u2502 73             \u2502 195            \u2502 27.92 \u2502\n\n\n\n\n\n\nReading from pipes\n\n\nJulia can run external programs, especially shell script, from within the REPL. The backtick notation is used to represent commands. For commands that return pipes, or streams of data, Julia can treat the output as a file to read the DataFrame. The general syntax for such a workflow is:\n\n\njulia\n open(`COMMAND`) do f\n          readtable(f)\n       end\n\n\n\n\nThe file \nbaseball_players.tsv.gz\n can be uncompressed onto STDOUT using the command $gzip -cd baseball_players.tsv.gz$. The DataFrame can therefore be read as:\n\n\njulia\n filename = joinpath(Pkg.dir(\nJuliaCookbook\n), \ndatasets\n, \nbaseball_players.tsv.gz\n) # Locate the dataset\njulia\n open(`gzip -cd $filename`) do f\n           readtable(f; allowcomments=true, separator='\\t')\n       end\n1034\u00d76 DataFrames.DataFrame\n\u2502 Row  \u2502 Name                 \u2502 Team  \u2502 Position            \u2502 Height_inches_ \u2502 Weight_pounds_ \u2502 Age   \u2502\n\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\n\u2502 1    \u2502 \nAdam_Donachie\n      \u2502 \nBAL\n \u2502 \nCatcher\n           \u2502 74             \u2502 180            \u2502 22.99 \u2502\n\u2502 2    \u2502 \nPaul_Bako\n          \u2502 \nBAL\n \u2502 \nCatcher\n           \u2502 74             \u2502 215            \u2502 34.69 \u2502\n\u2502 3    \u2502 \nRamon_Hernandez\n    \u2502 \nBAL\n \u2502 \nCatcher\n           \u2502 72             \u2502 210            \u2502 30.78 \u2502\n\u2502 4    \u2502 \nKevin_Millar\n       \u2502 \nBAL\n \u2502 \nFirst_Baseman\n     \u2502 72             \u2502 210            \u2502 35.43 \u2502\n\u2502 5    \u2502 \nChris_Gomez\n        \u2502 \nBAL\n \u2502 \nFirst_Baseman\n     \u2502 73             \u2502 188            \u2502 35.71 \u2502\n\u22ee\n\u2502 1030 \u2502 \nBrad_Thompson\n      \u2502 \nSTL\n \u2502 \nRelief_Pitcher\n    \u2502 73             \u2502 190            \u2502 25.08 \u2502\n\u2502 1031 \u2502 \nTyler_Johnson\n      \u2502 \nSTL\n \u2502 \nRelief_Pitcher\n    \u2502 74             \u2502 180            \u2502 25.73 \u2502\n\u2502 1032 \u2502 \nChris_Narveson\n     \u2502 \nSTL\n \u2502 \nRelief_Pitcher\n    \u2502 75             \u2502 205            \u2502 25.19 \u2502\n\u2502 1033 \u2502 \nRandy_Keisler\n      \u2502 \nSTL\n \u2502 \nRelief_Pitcher\n    \u2502 75             \u2502 190            \u2502 31.01 \u2502\n\u2502 1034 \u2502 \nJosh_Kinney\n        \u2502 \nSTL\n \u2502 \nRelief_Pitcher\n    \u2502 73             \u2502 195            \u2502 27.92 \u2502\n\n\n\n\nYou could also extract a DataFrame from the output of a Perl script. For example, if you want only alternate rows in the DataFrame, you would do:\n\n\njulia\n filename = joinpath(Pkg.dir(\nJuliaCookbook\n), \ndatasets\n, \nbaseball_players.tsv\n) # Locate the dataset\njulia\n open(`perl -ne 'print if $. %2' $filename`) do f\n           readtable(f; allowcomments=true, separator='\\t')\n       end\n517\u00d76 DataFrames.DataFrame\n\u2502 Row \u2502 Name               \u2502 Team  \u2502 Position           \u2502 Height_inches_ \u2502 Weight_pounds_ \u2502 Age   \u2502\n\u251c\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\n\u2502 1   \u2502 \nPaul_Bako\n        \u2502 \nBAL\n \u2502 \nCatcher\n          \u2502 74             \u2502 215            \u2502 34.69 \u2502\n\u2502 2   \u2502 \nKevin_Millar\n     \u2502 \nBAL\n \u2502 \nFirst_Baseman\n    \u2502 72             \u2502 210            \u2502 35.43 \u2502\n\u2502 3   \u2502 \nBrian_Roberts\n    \u2502 \nBAL\n \u2502 \nSecond_Baseman\n   \u2502 69             \u2502 176            \u2502 29.39 \u2502\n\u2502 4   \u2502 \nMelvin_Mora\n      \u2502 \nBAL\n \u2502 \nThird_Baseman\n    \u2502 71             \u2502 200            \u2502 35.07 \u2502\n\u2502 5   \u2502 \nAdam_Stern\n       \u2502 \nBAL\n \u2502 \nOutfielder\n       \u2502 71             \u2502 180            \u2502 27.05 \u2502\n\u22ee\n\u2502 513 \u2502 \nRicardo_Rincon\n   \u2502 \nSTL\n \u2502 \nRelief_Pitcher\n   \u2502 69             \u2502 190            \u2502 36.88 \u2502\n\u2502 514 \u2502 \nRandy_Flores\n     \u2502 \nSTL\n \u2502 \nRelief_Pitcher\n   \u2502 72             \u2502 180            \u2502 31.58 \u2502\n\u2502 515 \u2502 \nBrad_Thompson\n    \u2502 \nSTL\n \u2502 \nRelief_Pitcher\n   \u2502 73             \u2502 190            \u2502 25.08 \u2502\n\u2502 516 \u2502 \nChris_Narveson\n   \u2502 \nSTL\n \u2502 \nRelief_Pitcher\n   \u2502 75             \u2502 205            \u2502 25.19 \u2502\n\u2502 517 \u2502 \nJosh_Kinney\n      \u2502 \nSTL\n \u2502 \nRelief_Pitcher\n   \u2502 73             \u2502 195            \u2502 27.92 \u2502\n\n\n\n\nJulia allows a command to pipe its output into the next command, using the \npipeline\n method. The general syntax for such a construct would be:\n\n\njulia\n pipeline(`COMMAND_1`, `COMMAND_2` ... `COMMAND_N`)\n\n\n\n\nA DataFrame consisting of alternate rows can be extracted from the compressed dataset by running:\n\n\njulia\n filename = joinpath(Pkg.dir(\nJuliaCookbook\n), \ndatasets\n, \nbaseball_players.tsv.gz\n) # Locate the dataset\njulia\n open(pipeline(`gzip -cd $filename`, `perl -ne 'print if $. % 2'`)) do f\n          readtable(f; allowcomments=true, separator='\\t')\n       end\n517\u00d76 DataFrames.DataFrame\n\u2502 Row \u2502 Name               \u2502 Team  \u2502 Position           \u2502 Height_inches_ \u2502 Weight_pounds_ \u2502 Age   \u2502\n\u251c\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\n\u2502 1   \u2502 \nPaul_Bako\n        \u2502 \nBAL\n \u2502 \nCatcher\n          \u2502 74             \u2502 215            \u2502 34.69 \u2502\n\u2502 2   \u2502 \nKevin_Millar\n     \u2502 \nBAL\n \u2502 \nFirst_Baseman\n    \u2502 72             \u2502 210            \u2502 35.43 \u2502\n\u2502 3   \u2502 \nBrian_Roberts\n    \u2502 \nBAL\n \u2502 \nSecond_Baseman\n   \u2502 69             \u2502 176            \u2502 29.39 \u2502\n\u2502 4   \u2502 \nMelvin_Mora\n      \u2502 \nBAL\n \u2502 \nThird_Baseman\n    \u2502 71             \u2502 200            \u2502 35.07 \u2502\n\u2502 5   \u2502 \nAdam_Stern\n       \u2502 \nBAL\n \u2502 \nOutfielder\n       \u2502 71             \u2502 180            \u2502 27.05 \u2502\n\u22ee\n\u2502 513 \u2502 \nRicardo_Rincon\n   \u2502 \nSTL\n \u2502 \nRelief_Pitcher\n   \u2502 69             \u2502 190            \u2502 36.88 \u2502\n\u2502 514 \u2502 \nRandy_Flores\n     \u2502 \nSTL\n \u2502 \nRelief_Pitcher\n   \u2502 72             \u2502 180            \u2502 31.58 \u2502\n\u2502 515 \u2502 \nBrad_Thompson\n    \u2502 \nSTL\n \u2502 \nRelief_Pitcher\n   \u2502 73             \u2502 190            \u2502 25.08 \u2502\n\u2502 516 \u2502 \nChris_Narveson\n   \u2502 \nSTL\n \u2502 \nRelief_Pitcher\n   \u2502 75             \u2502 205            \u2502 25.19 \u2502\n\u2502 517 \u2502 \nJosh_Kinney\n      \u2502 \nSTL\n \u2502 \nRelief_Pitcher\n   \u2502 73             \u2502 195            \u2502 27.92 \u2502", 
            "title": "File IO"
        }, 
        {
            "location": "/dataframes/file_input/#reading-delimiter-separated-data", 
            "text": "The  readtable  function from  DataFrames.jl  can be used to read the contents of a  CSV/TSV/WSV  file into a DataFrame. A call to  readtable  typically looks like:  readtable( FILENAME ; [KEYWORD_ARGS]...)  Some of the keyword arguments, described in the  readtable  docstring, are:   header::Bool=true  \u2013 Use the information from the file's header line to determine column names.  separator::Char  \u2013 Assume that fields are split by the separator character. If not specified, it will be guessed from the filename.  allowcomments::Bool=false  \u2013 Ignore all text inside comments. Defaults to false.  skipblanks::Bool=true  \u2013 Skip any blank lines in input. Defaults to true.   You can see the entire list of keyword arguments using:  julia  ?readtable  Since the dataset has commented lines, we set the  allowcomments  argument to  true .  julia  filename = joinpath(Pkg.dir( JuliaCookbook ),  datasets ,  baseball_players.tsv ) # Locate the dataset\njulia  df = readtable(filename; allowcomments=true)                                      # Read the DataFrame\n1033\u00d76 DataFrames.DataFrame\n\u2502 Row  \u2502 Name                 \u2502 Team  \u2502 Position            \u2502 Height_inches_ \u2502 Weight_pounds_ \u2502 Age   \u2502\n\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\n\u2502 1    \u2502  Adam_Donachie       \u2502  BAL  \u2502  Catcher            \u2502 74             \u2502 180            \u2502 22.99 \u2502\n\u2502 2    \u2502  Paul_Bako           \u2502  BAL  \u2502  Catcher            \u2502 74             \u2502 215            \u2502 34.69 \u2502\n\u2502 3    \u2502  Ramon_Hernandez     \u2502  BAL  \u2502  Catcher            \u2502 72             \u2502 210            \u2502 30.78 \u2502\n\u2502 4    \u2502  Kevin_Millar        \u2502  BAL  \u2502  First_Baseman      \u2502 72             \u2502 210            \u2502 35.43 \u2502\n\u2502 5    \u2502  Chris_Gomez         \u2502  BAL  \u2502  First_Baseman      \u2502 73             \u2502 188            \u2502 35.71 \u2502\n\u2502 6    \u2502  Brian_Roberts       \u2502  BAL  \u2502  Second_Baseman     \u2502 69             \u2502 176            \u2502 29.39 \u2502\n\u2502 7    \u2502  Miguel_Tejada       \u2502  BAL  \u2502  Shortstop          \u2502 69             \u2502 209            \u2502 30.77 \u2502\n\u2502 8    \u2502  Melvin_Mora         \u2502  BAL  \u2502  Third_Baseman      \u2502 71             \u2502 200            \u2502 35.07 \u2502\n\u2502 9    \u2502  Aubrey_Huff         \u2502  BAL  \u2502  Third_Baseman      \u2502 76             \u2502 231            \u2502 30.19 \u2502\n\u2502 10   \u2502  Adam_Stern          \u2502  BAL  \u2502  Outfielder         \u2502 71             \u2502 180            \u2502 27.05 \u2502\n\u22ee\n\u2502 1025 \u2502  Jason_Isringhausen  \u2502  STL  \u2502  Relief_Pitcher     \u2502 75             \u2502 230            \u2502 34.48 \u2502\n\u2502 1026 \u2502  Ricardo_Rincon      \u2502  STL  \u2502  Relief_Pitcher     \u2502 69             \u2502 190            \u2502 36.88 \u2502\n\u2502 1027 \u2502  Braden_Looper       \u2502  STL  \u2502  Relief_Pitcher     \u2502 75             \u2502 220            \u2502 32.34 \u2502\n\u2502 1028 \u2502  Randy_Flores        \u2502  STL  \u2502  Relief_Pitcher     \u2502 72             \u2502 180            \u2502 31.58 \u2502\n\u2502 1029 \u2502  Josh_Hancock        \u2502  STL  \u2502  Relief_Pitcher     \u2502 75             \u2502 205            \u2502 28.89 \u2502\n\u2502 1030 \u2502  Brad_Thompson       \u2502  STL  \u2502  Relief_Pitcher     \u2502 73             \u2502 190            \u2502 25.08 \u2502\n\u2502 1031 \u2502  Tyler_Johnson       \u2502  STL  \u2502  Relief_Pitcher     \u2502 74             \u2502 180            \u2502 25.73 \u2502\n\u2502 1032 \u2502  Chris_Narveson      \u2502  STL  \u2502  Relief_Pitcher     \u2502 75             \u2502 205            \u2502 25.19 \u2502\n\u2502 1033 \u2502  Randy_Keisler       \u2502  STL  \u2502  Relief_Pitcher     \u2502 75             \u2502 190            \u2502 31.01 \u2502\n\u2502 1034 \u2502  Josh_Kinney         \u2502  STL  \u2502  Relief_Pitcher     \u2502 73             \u2502 195            \u2502 27.92 \u2502", 
            "title": "Reading Delimiter-Separated data"
        }, 
        {
            "location": "/dataframes/file_input/#handling-different-comment-marks", 
            "text": "The  readtable  function assumes that comment lines begin with the '#' character. Therefore, the default  readtable  invocation looks like:  julia  readtable( FILE_NAME ; allowcomments=true, commentmark='#')  If your dataset uses a different character to indicate commented lines, specify the character using the  commentmark  keyword argument. For example, if your dataset uses the  %  character:  julia  readtable( FILE_NAME ; allowcomments=true, commentmark='%')", 
            "title": "Handling different comment marks"
        }, 
        {
            "location": "/dataframes/file_input/#multiple-missing-value-strings", 
            "text": "By default,  readtable  translates the strings  \"\"  and  \"NA\"  into null values or  NA s. If your dataset uses different or additional strings to represent null values, you can set the  nastrings  keyword argument to these strings. For example, if your dataset contains  \"null\" ,  \"NULL\"  and  \"-\"  to indicate null values, then run:  julia  readtable( FILE_NAME ; nastrings=[ null ,  NULL ,  - ])", 
            "title": "Multiple missing value strings"
        }, 
        {
            "location": "/dataframes/file_input/#reading-a-subset-of-rows", 
            "text": "By default,  readtable  reads the entire file into a dataframe. Therefore, the default  readtable  invocation looks like:  julia  readtable( FILE_NAME ; nrows=-1)  If you're interested in the first few lines or don't want to overwhelm your memory, specify the number of rows you want to read with the  nrows  keyword argument. For example, to read the first 500 lines:  julia  readtable( FILE_NAME ; nrows=500)  If you want to skip the first few lines, set the  skipstart  keyword argument. For example to skip the first 500 lines:  julia  readtable( FILE_NAME ; skipstart=500)  To skip specific lines in the file, set the  skiprows  keyword argument to an array containing the rows you want to skip. For example to skip rows  [10, 50, 100] :  julia  readtable( FILE_NAME ; skiplines=[10, 50, 100])  A complex combination of lines can be read by using one or more of  nrows ,  skipstart  and  skiprows .", 
            "title": "Reading a subset of rows"
        }, 
        {
            "location": "/dataframes/file_input/#reading-from-compressed-files", 
            "text": "The GZip package can be used to read  DataFrame s from compressed files. The general syntax to do this is:  julia  GZip.open( FILE_NAME.gz ) do f\n           readtable(f; [KEYWORD_ARGS]...)\n       end  To read a compressed version of the baseball players dataset:  julia  filename = joinpath(Pkg.dir( JuliaCookbook ),  datasets ,  baseball_players.tsv.gz ) # Locate the dataset\njulia  GZip.open(filename) do f\n           readtable(f; allowcomments=true, separator='\\t')\n       end\n1034\u00d76 DataFrames.DataFrame\n\u2502 Row  \u2502 Name                 \u2502 Team  \u2502 Position            \u2502 Height_inches_ \u2502 Weight_pounds_ \u2502 Age   \u2502\n\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\n\u2502 1    \u2502  Adam_Donachie       \u2502  BAL  \u2502  Catcher            \u2502 74             \u2502 180            \u2502 22.99 \u2502\n\u2502 2    \u2502  Paul_Bako           \u2502  BAL  \u2502  Catcher            \u2502 74             \u2502 215            \u2502 34.69 \u2502\n\u2502 3    \u2502  Ramon_Hernandez     \u2502  BAL  \u2502  Catcher            \u2502 72             \u2502 210            \u2502 30.78 \u2502\n\u2502 4    \u2502  Kevin_Millar        \u2502  BAL  \u2502  First_Baseman      \u2502 72             \u2502 210            \u2502 35.43 \u2502\n\u2502 5    \u2502  Chris_Gomez         \u2502  BAL  \u2502  First_Baseman      \u2502 73             \u2502 188            \u2502 35.71 \u2502\n  \u22ee\n\u2502 1030 \u2502  Brad_Thompson       \u2502  STL  \u2502  Relief_Pitcher     \u2502 73             \u2502 190            \u2502 25.08 \u2502\n\u2502 1031 \u2502  Tyler_Johnson       \u2502  STL  \u2502  Relief_Pitcher     \u2502 74             \u2502 180            \u2502 25.73 \u2502\n\u2502 1032 \u2502  Chris_Narveson      \u2502  STL  \u2502  Relief_Pitcher     \u2502 75             \u2502 205            \u2502 25.19 \u2502\n\u2502 1033 \u2502  Randy_Keisler       \u2502  STL  \u2502  Relief_Pitcher     \u2502 75             \u2502 190            \u2502 31.01 \u2502\n\u2502 1034 \u2502  Josh_Kinney         \u2502  STL  \u2502  Relief_Pitcher     \u2502 73             \u2502 195            \u2502 27.92 \u2502", 
            "title": "Reading from compressed files"
        }, 
        {
            "location": "/dataframes/file_input/#reading-from-pipes", 
            "text": "Julia can run external programs, especially shell script, from within the REPL. The backtick notation is used to represent commands. For commands that return pipes, or streams of data, Julia can treat the output as a file to read the DataFrame. The general syntax for such a workflow is:  julia  open(`COMMAND`) do f\n          readtable(f)\n       end  The file  baseball_players.tsv.gz  can be uncompressed onto STDOUT using the command $gzip -cd baseball_players.tsv.gz$. The DataFrame can therefore be read as:  julia  filename = joinpath(Pkg.dir( JuliaCookbook ),  datasets ,  baseball_players.tsv.gz ) # Locate the dataset\njulia  open(`gzip -cd $filename`) do f\n           readtable(f; allowcomments=true, separator='\\t')\n       end\n1034\u00d76 DataFrames.DataFrame\n\u2502 Row  \u2502 Name                 \u2502 Team  \u2502 Position            \u2502 Height_inches_ \u2502 Weight_pounds_ \u2502 Age   \u2502\n\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\n\u2502 1    \u2502  Adam_Donachie       \u2502  BAL  \u2502  Catcher            \u2502 74             \u2502 180            \u2502 22.99 \u2502\n\u2502 2    \u2502  Paul_Bako           \u2502  BAL  \u2502  Catcher            \u2502 74             \u2502 215            \u2502 34.69 \u2502\n\u2502 3    \u2502  Ramon_Hernandez     \u2502  BAL  \u2502  Catcher            \u2502 72             \u2502 210            \u2502 30.78 \u2502\n\u2502 4    \u2502  Kevin_Millar        \u2502  BAL  \u2502  First_Baseman      \u2502 72             \u2502 210            \u2502 35.43 \u2502\n\u2502 5    \u2502  Chris_Gomez         \u2502  BAL  \u2502  First_Baseman      \u2502 73             \u2502 188            \u2502 35.71 \u2502\n\u22ee\n\u2502 1030 \u2502  Brad_Thompson       \u2502  STL  \u2502  Relief_Pitcher     \u2502 73             \u2502 190            \u2502 25.08 \u2502\n\u2502 1031 \u2502  Tyler_Johnson       \u2502  STL  \u2502  Relief_Pitcher     \u2502 74             \u2502 180            \u2502 25.73 \u2502\n\u2502 1032 \u2502  Chris_Narveson      \u2502  STL  \u2502  Relief_Pitcher     \u2502 75             \u2502 205            \u2502 25.19 \u2502\n\u2502 1033 \u2502  Randy_Keisler       \u2502  STL  \u2502  Relief_Pitcher     \u2502 75             \u2502 190            \u2502 31.01 \u2502\n\u2502 1034 \u2502  Josh_Kinney         \u2502  STL  \u2502  Relief_Pitcher     \u2502 73             \u2502 195            \u2502 27.92 \u2502  You could also extract a DataFrame from the output of a Perl script. For example, if you want only alternate rows in the DataFrame, you would do:  julia  filename = joinpath(Pkg.dir( JuliaCookbook ),  datasets ,  baseball_players.tsv ) # Locate the dataset\njulia  open(`perl -ne 'print if $. %2' $filename`) do f\n           readtable(f; allowcomments=true, separator='\\t')\n       end\n517\u00d76 DataFrames.DataFrame\n\u2502 Row \u2502 Name               \u2502 Team  \u2502 Position           \u2502 Height_inches_ \u2502 Weight_pounds_ \u2502 Age   \u2502\n\u251c\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\n\u2502 1   \u2502  Paul_Bako         \u2502  BAL  \u2502  Catcher           \u2502 74             \u2502 215            \u2502 34.69 \u2502\n\u2502 2   \u2502  Kevin_Millar      \u2502  BAL  \u2502  First_Baseman     \u2502 72             \u2502 210            \u2502 35.43 \u2502\n\u2502 3   \u2502  Brian_Roberts     \u2502  BAL  \u2502  Second_Baseman    \u2502 69             \u2502 176            \u2502 29.39 \u2502\n\u2502 4   \u2502  Melvin_Mora       \u2502  BAL  \u2502  Third_Baseman     \u2502 71             \u2502 200            \u2502 35.07 \u2502\n\u2502 5   \u2502  Adam_Stern        \u2502  BAL  \u2502  Outfielder        \u2502 71             \u2502 180            \u2502 27.05 \u2502\n\u22ee\n\u2502 513 \u2502  Ricardo_Rincon    \u2502  STL  \u2502  Relief_Pitcher    \u2502 69             \u2502 190            \u2502 36.88 \u2502\n\u2502 514 \u2502  Randy_Flores      \u2502  STL  \u2502  Relief_Pitcher    \u2502 72             \u2502 180            \u2502 31.58 \u2502\n\u2502 515 \u2502  Brad_Thompson     \u2502  STL  \u2502  Relief_Pitcher    \u2502 73             \u2502 190            \u2502 25.08 \u2502\n\u2502 516 \u2502  Chris_Narveson    \u2502  STL  \u2502  Relief_Pitcher    \u2502 75             \u2502 205            \u2502 25.19 \u2502\n\u2502 517 \u2502  Josh_Kinney       \u2502  STL  \u2502  Relief_Pitcher    \u2502 73             \u2502 195            \u2502 27.92 \u2502  Julia allows a command to pipe its output into the next command, using the  pipeline  method. The general syntax for such a construct would be:  julia  pipeline(`COMMAND_1`, `COMMAND_2` ... `COMMAND_N`)  A DataFrame consisting of alternate rows can be extracted from the compressed dataset by running:  julia  filename = joinpath(Pkg.dir( JuliaCookbook ),  datasets ,  baseball_players.tsv.gz ) # Locate the dataset\njulia  open(pipeline(`gzip -cd $filename`, `perl -ne 'print if $. % 2'`)) do f\n          readtable(f; allowcomments=true, separator='\\t')\n       end\n517\u00d76 DataFrames.DataFrame\n\u2502 Row \u2502 Name               \u2502 Team  \u2502 Position           \u2502 Height_inches_ \u2502 Weight_pounds_ \u2502 Age   \u2502\n\u251c\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\n\u2502 1   \u2502  Paul_Bako         \u2502  BAL  \u2502  Catcher           \u2502 74             \u2502 215            \u2502 34.69 \u2502\n\u2502 2   \u2502  Kevin_Millar      \u2502  BAL  \u2502  First_Baseman     \u2502 72             \u2502 210            \u2502 35.43 \u2502\n\u2502 3   \u2502  Brian_Roberts     \u2502  BAL  \u2502  Second_Baseman    \u2502 69             \u2502 176            \u2502 29.39 \u2502\n\u2502 4   \u2502  Melvin_Mora       \u2502  BAL  \u2502  Third_Baseman     \u2502 71             \u2502 200            \u2502 35.07 \u2502\n\u2502 5   \u2502  Adam_Stern        \u2502  BAL  \u2502  Outfielder        \u2502 71             \u2502 180            \u2502 27.05 \u2502\n\u22ee\n\u2502 513 \u2502  Ricardo_Rincon    \u2502  STL  \u2502  Relief_Pitcher    \u2502 69             \u2502 190            \u2502 36.88 \u2502\n\u2502 514 \u2502  Randy_Flores      \u2502  STL  \u2502  Relief_Pitcher    \u2502 72             \u2502 180            \u2502 31.58 \u2502\n\u2502 515 \u2502  Brad_Thompson     \u2502  STL  \u2502  Relief_Pitcher    \u2502 73             \u2502 190            \u2502 25.08 \u2502\n\u2502 516 \u2502  Chris_Narveson    \u2502  STL  \u2502  Relief_Pitcher    \u2502 75             \u2502 205            \u2502 25.19 \u2502\n\u2502 517 \u2502  Josh_Kinney       \u2502  STL  \u2502  Relief_Pitcher    \u2502 73             \u2502 195            \u2502 27.92 \u2502", 
            "title": "Reading from pipes"
        }, 
        {
            "location": "/dataframes/accessors/", 
            "text": "Accessors\n\n\nThis file describes methods to access the columns and rows contained in the \nDataFrame\n. The \nbaseball_players\n dataset is used in all examples. You can load it using:\n\n\njulia\n filename = joinpath(Pkg.dir(\nJuliaCookbook\n), \ndatasets\n, \nbaseball_players.tsv\n) # Locate the dataset\njulia\n df = readtable(filename; allowcomments=true)                                      # Read the DataFrame\n\n\n\n\n\n\nListing out columns\n\n\nA list of columns in the DataFrame can be obtained by running \nnames(DATAFRAME)\n:\n\n\njulia\n names(df)\n6-element Array{Symbol,1}:\n :Name\n :Team\n :Position\n :Height_inches_\n :Weight_pounds_\n :Age\n ```\n\n The data types contained in the columns can be list out using `eltypes(DATAFRAME)`:\n\n ```julia\n julia\n eltypes(df)\n 6-element Array{Type,1}:\n String\n String\n String\n Int64\n Int64\n Float64\n ```\n\n## Selecting Columns\n\nThe `DataFrame` object behaves like a 2D array. Therefore, the first column (Name) can be extracted by simply running:\n\n\n\n\njulia julia\n df[1] 1034-element DataArrays.DataArray{String,1}:  \"Adam_Donachie\"  \"Paul_Bako\"  \"Ramon_Hernandez\"  \"Kevin_Millar\"  \"Chris_Gomez\"  \u22ee  \"Brad_Thompson\"  \"Tyler_Johnson\"  \"Chris_Narveson\"  \"Randy_Keisler\"  \"Josh_Kinney\"\n\n\n\nColumns can also be extracted by specifying a column-name. The column-name is supplied using a Symbol.\n\n\n\n\n\njulia julia\n df[:Age] 1034-element DataArrays.DataArray{Float64,1}:  22.99  34.69  30.78  35.43  35.71   \u22ee  25.08  25.73  25.19  31.01  27.92\n\n\n\n## Selecting Rows\n\nThe `DataFrame` object's 2D array behavior can be used to fetch rows, in a Sub-DataFrame.\n\n\n\n\n\njulia julia\n df[1:5, :] 5\u00d76 DataFrames.DataFrame \u2502 Row \u2502 Name              \u2502 Team  \u2502 Position        \u2502 Height_inches_ \u2502 Weight_pounds_ \u2502 Age   \u2502 \u251c\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524 \u2502 1   \u2502 \"Adam_Donachie\"   \u2502 \"BAL\" \u2502 \"Catcher\"       \u2502 74             \u2502 180            \u2502 22.99 \u2502 \u2502 2   \u2502 \"Paul_Bako\"       \u2502 \"BAL\" \u2502 \"Catcher\"       \u2502 74             \u2502 215            \u2502 34.69 \u2502 \u2502 3   \u2502 \"Ramon_Hernandez\" \u2502 \"BAL\" \u2502 \"Catcher\"       \u2502 72             \u2502 210            \u2502 30.78 \u2502 \u2502 4   \u2502 \"Kevin_Millar\"    \u2502 \"BAL\" \u2502 \"First_Baseman\" \u2502 72             \u2502 210            \u2502 35.43 \u2502 \u2502 5   \u2502 \"Chris_Gomez\"     \u2502 \"BAL\" \u2502 \"First_Baseman\" \u2502 73             \u2502 188            \u2502 35.71 \u2502\n\n\n\nA subset of columns can also be fetched:\n\n\n\n\n\njulia julia\n df[1:5, [:Name, :Position, :Age]] 5\u00d73 DataFrames.DataFrame \u2502 Row \u2502 Name              \u2502 Position        \u2502 Age   \u2502 \u251c\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524 \u2502 1   \u2502 \"Adam_Donachie\"   \u2502 \"Catcher\"       \u2502 22.99 \u2502 \u2502 2   \u2502 \"Paul_Bako\"       \u2502 \"Catcher\"       \u2502 34.69 \u2502 \u2502 3   \u2502 \"Ramon_Hernandez\" \u2502 \"Catcher\"       \u2502 30.78 \u2502 \u2502 4   \u2502 \"Kevin_Millar\"    \u2502 \"First_Baseman\" \u2502 35.43 \u2502 \u2502 5   \u2502 \"Chris_Gomez\"     \u2502 \"First_Baseman\" \u2502 35.71 \u2502\n\n\n\n## Null Values\n\nReal world data samples are often incomplete, and therefore the `DataFrames` package uses the `NA` object to denote a null value, or the absence of data.\n\nThe `NA` objects poisons the data, and must be removed before any data analysis can be done. For example,\n`Kirk_Saarloos`'s weight is missing in the dataset (Row 641). Therefore, it's not possible to calculate the mean weight\nof baseball players until his data is removed.\n\n\n\n\n\njulia julia\n mean(df[:Weight_pounds_])         # Poisoned data NA\n\n\njulia\n mean(dropna(df[:Weight_pounds_])) # Mean of un-poisoned data 201.6892545982575\n\n\n\nAlternatively, the entire row containing `Kirk_Saarloos`'s data can be deleted.\n\n\n\n\njulia deleterows!(df, 641) ```", 
            "title": "Data Access"
        }, 
        {
            "location": "/dataframes/accessors/#accessors", 
            "text": "This file describes methods to access the columns and rows contained in the  DataFrame . The  baseball_players  dataset is used in all examples. You can load it using:  julia  filename = joinpath(Pkg.dir( JuliaCookbook ),  datasets ,  baseball_players.tsv ) # Locate the dataset\njulia  df = readtable(filename; allowcomments=true)                                      # Read the DataFrame", 
            "title": "Accessors"
        }, 
        {
            "location": "/dataframes/accessors/#listing-out-columns", 
            "text": "A list of columns in the DataFrame can be obtained by running  names(DATAFRAME) :  julia  names(df)\n6-element Array{Symbol,1}:\n :Name\n :Team\n :Position\n :Height_inches_\n :Weight_pounds_\n :Age\n ```\n\n The data types contained in the columns can be list out using `eltypes(DATAFRAME)`:\n\n ```julia\n julia  eltypes(df)\n 6-element Array{Type,1}:\n String\n String\n String\n Int64\n Int64\n Float64\n ```\n\n## Selecting Columns\n\nThe `DataFrame` object behaves like a 2D array. Therefore, the first column (Name) can be extracted by simply running:  julia julia  df[1] 1034-element DataArrays.DataArray{String,1}:  \"Adam_Donachie\"  \"Paul_Bako\"  \"Ramon_Hernandez\"  \"Kevin_Millar\"  \"Chris_Gomez\"  \u22ee  \"Brad_Thompson\"  \"Tyler_Johnson\"  \"Chris_Narveson\"  \"Randy_Keisler\"  \"Josh_Kinney\"  \nColumns can also be extracted by specifying a column-name. The column-name is supplied using a Symbol.  julia julia  df[:Age] 1034-element DataArrays.DataArray{Float64,1}:  22.99  34.69  30.78  35.43  35.71   \u22ee  25.08  25.73  25.19  31.01  27.92  \n## Selecting Rows\n\nThe `DataFrame` object's 2D array behavior can be used to fetch rows, in a Sub-DataFrame.  julia julia  df[1:5, :] 5\u00d76 DataFrames.DataFrame \u2502 Row \u2502 Name              \u2502 Team  \u2502 Position        \u2502 Height_inches_ \u2502 Weight_pounds_ \u2502 Age   \u2502 \u251c\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524 \u2502 1   \u2502 \"Adam_Donachie\"   \u2502 \"BAL\" \u2502 \"Catcher\"       \u2502 74             \u2502 180            \u2502 22.99 \u2502 \u2502 2   \u2502 \"Paul_Bako\"       \u2502 \"BAL\" \u2502 \"Catcher\"       \u2502 74             \u2502 215            \u2502 34.69 \u2502 \u2502 3   \u2502 \"Ramon_Hernandez\" \u2502 \"BAL\" \u2502 \"Catcher\"       \u2502 72             \u2502 210            \u2502 30.78 \u2502 \u2502 4   \u2502 \"Kevin_Millar\"    \u2502 \"BAL\" \u2502 \"First_Baseman\" \u2502 72             \u2502 210            \u2502 35.43 \u2502 \u2502 5   \u2502 \"Chris_Gomez\"     \u2502 \"BAL\" \u2502 \"First_Baseman\" \u2502 73             \u2502 188            \u2502 35.71 \u2502  \nA subset of columns can also be fetched:  julia julia  df[1:5, [:Name, :Position, :Age]] 5\u00d73 DataFrames.DataFrame \u2502 Row \u2502 Name              \u2502 Position        \u2502 Age   \u2502 \u251c\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524 \u2502 1   \u2502 \"Adam_Donachie\"   \u2502 \"Catcher\"       \u2502 22.99 \u2502 \u2502 2   \u2502 \"Paul_Bako\"       \u2502 \"Catcher\"       \u2502 34.69 \u2502 \u2502 3   \u2502 \"Ramon_Hernandez\" \u2502 \"Catcher\"       \u2502 30.78 \u2502 \u2502 4   \u2502 \"Kevin_Millar\"    \u2502 \"First_Baseman\" \u2502 35.43 \u2502 \u2502 5   \u2502 \"Chris_Gomez\"     \u2502 \"First_Baseman\" \u2502 35.71 \u2502  \n## Null Values\n\nReal world data samples are often incomplete, and therefore the `DataFrames` package uses the `NA` object to denote a null value, or the absence of data.\n\nThe `NA` objects poisons the data, and must be removed before any data analysis can be done. For example,\n`Kirk_Saarloos`'s weight is missing in the dataset (Row 641). Therefore, it's not possible to calculate the mean weight\nof baseball players until his data is removed.  julia julia  mean(df[:Weight_pounds_])         # Poisoned data NA  julia  mean(dropna(df[:Weight_pounds_])) # Mean of un-poisoned data 201.6892545982575  \nAlternatively, the entire row containing `Kirk_Saarloos`'s data can be deleted.  julia deleterows!(df, 641) ```", 
            "title": "Listing out columns"
        }, 
        {
            "location": "/dataframes/RDatasets/", 
            "text": "R Datasets\n\n\nIf you miss the standard datasets from R, or just need a few sample datasets to get familiar with DataFrames, the \nRDatasets\n package would be a great place to look.\n\n\nThe list of R packages, from which datasets are available, can be obtained using:\n\n\njulia\n RDatasets.packages()\n33\u00d72 DataFrames.DataFrame\n\u2502 Row \u2502 Package        \u2502 Title                                                                     \u2502\n\u251c\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\n\u2502 1   \u2502 \nCOUNT\n        \u2502 \nFunctions, data and code for count data.\n                                \u2502\n\u2502 2   \u2502 \nEcdat\n        \u2502 \nData sets for econometrics\n                                              \u2502\n\u2502 3   \u2502 \nHSAUR\n        \u2502 \nA Handbook of Statistical Analyses Using R (1st Edition)\n                \u2502\n\u2502 4   \u2502 \nHistData\n     \u2502 \nData sets from the history of statistics and data visualization\n         \u2502\n\u2502 5   \u2502 \nISLR\n         \u2502 \nData for An Introduction to Statistical Learning with Applications in R\n \u2502\n  \u22ee\n\u2502 29  \u2502 \nrpart\n        \u2502 \nRecursive Partitioning and Regression Trees\n                             \u2502\n\u2502 30  \u2502 \nsandwich\n     \u2502 \nRobust Covariance Matrix Estimators\n                                     \u2502\n\u2502 31  \u2502 \nsem\n          \u2502 \nStructural Equation Models\n                                              \u2502\n\u2502 32  \u2502 \nsurvival\n     \u2502 \nSurvival Analysis\n                                                       \u2502\n\u2502 33  \u2502 \nvcd\n          \u2502 \nVisualizing Categorical Data\n                                            \u2502\n\n\n\n\nThe datasets available from each package can be obtained by running \nRDatasets.datasets(\"PACKAGE_NAME\")\n. For example, for a list of datasets for Econometrics, run:\n\n\njulia\n RDatasets.datasets(\nEcdat\n)\n93\u00d75 DataFrames.DataFrame\n\u2502 Row \u2502 Package \u2502 Dataset            \u2502 Title                                                      \u2502 Rows  \u2502 Columns \u2502\n\u251c\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\n\u2502 1   \u2502 \nEcdat\n \u2502 \nAccident\n         \u2502 \nShip Accidents\n                                           \u2502 40    \u2502 5       \u2502\n\u2502 2   \u2502 \nEcdat\n \u2502 \nAirline\n          \u2502 \nCost for U.S. Airlines\n                                   \u2502 90    \u2502 6       \u2502\n\u2502 3   \u2502 \nEcdat\n \u2502 \nAirq\n             \u2502 \nAir Quality for Californian Metropolitan Areas\n           \u2502 30    \u2502 6       \u2502\n\u2502 4   \u2502 \nEcdat\n \u2502 \nBenefits\n         \u2502 \nUnemployement of Blue Collar Workers\n                     \u2502 4877  \u2502 18      \u2502\n\u2502 5   \u2502 \nEcdat\n \u2502 \nBids\n             \u2502 \nBids Received By U.S. Firms\n                              \u2502 126   \u2502 12      \u2502\n  \u22ee\n\u2502 89  \u2502 \nEcdat\n \u2502 \nWages1\n           \u2502 \nWages, Experience and Schooling\n                          \u2502 3294  \u2502 4       \u2502\n\u2502 90  \u2502 \nEcdat\n \u2502 \nWorkinghours\n     \u2502 \nWife Working Hours\n                                       \u2502 3382  \u2502 12      \u2502\n\u2502 91  \u2502 \nEcdat\n \u2502 \nYen\n              \u2502 \nYen-dollar Exchange Rate\n                                 \u2502 778   \u2502 4       \u2502\n\u2502 92  \u2502 \nEcdat\n \u2502 \nYogurt\n           \u2502 \nChoice of Brand for Yogurts\n                              \u2502 2412  \u2502 10      \u2502\n\u2502 93  \u2502 \nEcdat\n \u2502 \nincomeInequality\n \u2502 \nIncome Inequality in the US\n                              \u2502 66    \u2502 22      \u2502\n\n\n\n\nOr you can simply get a long list of all supported datasets by running:\n\n\nRDatasets.datasets()\n\n\n\n\nOnce you've identified the dataset you wish to use, it can be loaded into a DataFrame by running \ndataset(\"PACKAGE_NAME\", \"DATASET_NAME\")\n. For example, you can load the dataset \nIncome Inequality in the US\n by running:\n\n\nineq = dataset(\nEcdat\n, \nincomeInequality\n)\n66\u00d722 DataFrames.DataFrame\n\u2502 Row \u2502 Year \u2502 NumberThousands \u2502 Quintile1 \u2502 \u2026 \u2502PersonsPerFamily \u2502 RealGDPPerFamily \u2502 MeanMedian \u2502\n\u251c\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2502   \u2502\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\n\u2502 1   \u2502 1947 \u2502 37237           \u2502 14243     \u2502 \u2026 \u2502 3.87051         \u2502 54641.2          \u2502 2.04158    \u2502\n\u2502 2   \u2502 1948 \u2502 38624           \u2502 13779     \u2502 \u2026 \u2502 3.79637         \u2502 54864.9          \u2502 2.09587    \u2502\n\u2502 3   \u2502 1949 \u2502 39303           \u2502 13007     \u2502 \u2026 \u2502 3.79584         \u2502 53623.1          \u2502 2.07767    \u2502\n\u2502 4   \u2502 1950 \u2502 39929           \u2502 13829     \u2502 \u2026 \u2502 3.79884         \u2502 57382.2          \u2502 2.09177    \u2502\n\u2502 5   \u2502 1951 \u2502 40578           \u2502 15070     \u2502 \u2026 \u2502 3.80223         \u2502 61013.9          \u2502 2.15917    \u2502\n\u2502 24  \u2502 1970 \u2502 52227           \u2502 26913     \u2502 \u2026 \u2502 3.92688         \u2502 94856.2          \u2502 1.85394    \u2502\n  \u22ee\n\u2502 62  \u2502 2008 \u2502 78874           \u2502 29646     \u2502 \u2026 \u2502 3.86113         \u2502 1.97489e5        \u2502 3.04476    \u2502\n\u2502 63  \u2502 2009 \u2502 78867           \u2502 28832     \u2502 \u2026 \u2502 3.89567         \u2502 1.91972e5        \u2502 3.02526    \u2502\n\u2502 64  \u2502 2010 \u2502 79559           \u2502 27928     \u2502 \u2026 \u2502 3.89366         \u2502 1.95073e5        \u2502 3.10811    \u2502\n\u2502 65  \u2502 2011 \u2502 80529           \u2502 27787     \u2502 \u2026 \u2502 3.87483         \u2502 1.96284e5        \u2502 3.18783    \u2502\n\u2502 66  \u2502 2012 \u2502 80944           \u2502 27794     \u2502 \u2026 \u2502 3.88266         \u2502 200704.0         \u2502 3.25129    \u2502", 
            "title": "R Datasets"
        }, 
        {
            "location": "/dataframes/RDatasets/#r-datasets", 
            "text": "If you miss the standard datasets from R, or just need a few sample datasets to get familiar with DataFrames, the  RDatasets  package would be a great place to look.  The list of R packages, from which datasets are available, can be obtained using:  julia  RDatasets.packages()\n33\u00d72 DataFrames.DataFrame\n\u2502 Row \u2502 Package        \u2502 Title                                                                     \u2502\n\u251c\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\n\u2502 1   \u2502  COUNT         \u2502  Functions, data and code for count data.                                 \u2502\n\u2502 2   \u2502  Ecdat         \u2502  Data sets for econometrics                                               \u2502\n\u2502 3   \u2502  HSAUR         \u2502  A Handbook of Statistical Analyses Using R (1st Edition)                 \u2502\n\u2502 4   \u2502  HistData      \u2502  Data sets from the history of statistics and data visualization          \u2502\n\u2502 5   \u2502  ISLR          \u2502  Data for An Introduction to Statistical Learning with Applications in R  \u2502\n  \u22ee\n\u2502 29  \u2502  rpart         \u2502  Recursive Partitioning and Regression Trees                              \u2502\n\u2502 30  \u2502  sandwich      \u2502  Robust Covariance Matrix Estimators                                      \u2502\n\u2502 31  \u2502  sem           \u2502  Structural Equation Models                                               \u2502\n\u2502 32  \u2502  survival      \u2502  Survival Analysis                                                        \u2502\n\u2502 33  \u2502  vcd           \u2502  Visualizing Categorical Data                                             \u2502  The datasets available from each package can be obtained by running  RDatasets.datasets(\"PACKAGE_NAME\") . For example, for a list of datasets for Econometrics, run:  julia  RDatasets.datasets( Ecdat )\n93\u00d75 DataFrames.DataFrame\n\u2502 Row \u2502 Package \u2502 Dataset            \u2502 Title                                                      \u2502 Rows  \u2502 Columns \u2502\n\u251c\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\n\u2502 1   \u2502  Ecdat  \u2502  Accident          \u2502  Ship Accidents                                            \u2502 40    \u2502 5       \u2502\n\u2502 2   \u2502  Ecdat  \u2502  Airline           \u2502  Cost for U.S. Airlines                                    \u2502 90    \u2502 6       \u2502\n\u2502 3   \u2502  Ecdat  \u2502  Airq              \u2502  Air Quality for Californian Metropolitan Areas            \u2502 30    \u2502 6       \u2502\n\u2502 4   \u2502  Ecdat  \u2502  Benefits          \u2502  Unemployement of Blue Collar Workers                      \u2502 4877  \u2502 18      \u2502\n\u2502 5   \u2502  Ecdat  \u2502  Bids              \u2502  Bids Received By U.S. Firms                               \u2502 126   \u2502 12      \u2502\n  \u22ee\n\u2502 89  \u2502  Ecdat  \u2502  Wages1            \u2502  Wages, Experience and Schooling                           \u2502 3294  \u2502 4       \u2502\n\u2502 90  \u2502  Ecdat  \u2502  Workinghours      \u2502  Wife Working Hours                                        \u2502 3382  \u2502 12      \u2502\n\u2502 91  \u2502  Ecdat  \u2502  Yen               \u2502  Yen-dollar Exchange Rate                                  \u2502 778   \u2502 4       \u2502\n\u2502 92  \u2502  Ecdat  \u2502  Yogurt            \u2502  Choice of Brand for Yogurts                               \u2502 2412  \u2502 10      \u2502\n\u2502 93  \u2502  Ecdat  \u2502  incomeInequality  \u2502  Income Inequality in the US                               \u2502 66    \u2502 22      \u2502  Or you can simply get a long list of all supported datasets by running:  RDatasets.datasets()  Once you've identified the dataset you wish to use, it can be loaded into a DataFrame by running  dataset(\"PACKAGE_NAME\", \"DATASET_NAME\") . For example, you can load the dataset  Income Inequality in the US  by running:  ineq = dataset( Ecdat ,  incomeInequality )\n66\u00d722 DataFrames.DataFrame\n\u2502 Row \u2502 Year \u2502 NumberThousands \u2502 Quintile1 \u2502 \u2026 \u2502PersonsPerFamily \u2502 RealGDPPerFamily \u2502 MeanMedian \u2502\n\u251c\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2502   \u2502\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\n\u2502 1   \u2502 1947 \u2502 37237           \u2502 14243     \u2502 \u2026 \u2502 3.87051         \u2502 54641.2          \u2502 2.04158    \u2502\n\u2502 2   \u2502 1948 \u2502 38624           \u2502 13779     \u2502 \u2026 \u2502 3.79637         \u2502 54864.9          \u2502 2.09587    \u2502\n\u2502 3   \u2502 1949 \u2502 39303           \u2502 13007     \u2502 \u2026 \u2502 3.79584         \u2502 53623.1          \u2502 2.07767    \u2502\n\u2502 4   \u2502 1950 \u2502 39929           \u2502 13829     \u2502 \u2026 \u2502 3.79884         \u2502 57382.2          \u2502 2.09177    \u2502\n\u2502 5   \u2502 1951 \u2502 40578           \u2502 15070     \u2502 \u2026 \u2502 3.80223         \u2502 61013.9          \u2502 2.15917    \u2502\n\u2502 24  \u2502 1970 \u2502 52227           \u2502 26913     \u2502 \u2026 \u2502 3.92688         \u2502 94856.2          \u2502 1.85394    \u2502\n  \u22ee\n\u2502 62  \u2502 2008 \u2502 78874           \u2502 29646     \u2502 \u2026 \u2502 3.86113         \u2502 1.97489e5        \u2502 3.04476    \u2502\n\u2502 63  \u2502 2009 \u2502 78867           \u2502 28832     \u2502 \u2026 \u2502 3.89567         \u2502 1.91972e5        \u2502 3.02526    \u2502\n\u2502 64  \u2502 2010 \u2502 79559           \u2502 27928     \u2502 \u2026 \u2502 3.89366         \u2502 1.95073e5        \u2502 3.10811    \u2502\n\u2502 65  \u2502 2011 \u2502 80529           \u2502 27787     \u2502 \u2026 \u2502 3.87483         \u2502 1.96284e5        \u2502 3.18783    \u2502\n\u2502 66  \u2502 2012 \u2502 80944           \u2502 27794     \u2502 \u2026 \u2502 3.88266         \u2502 200704.0         \u2502 3.25129    \u2502", 
            "title": "R Datasets"
        }, 
        {
            "location": "/dataframes/plotting/", 
            "text": "Plotting\n\n\nThe \nPlots.jl\n package is probably the best option for \nlinegraphs\n, \nscatterplots\n, \nhistograms\n etc.\n\n\n\n\nLine Graphs\n\n\nThe examples shown below use the \nIncome Inequality in the US\n dataset which can be loaded by running:\n\n\njulia\n ineq = dataset(\nEcdat\n, \nincomeInequality\n)\n\n\n\n\nIt would be interesting to see how the family incomes of the different sections of society have developed over the years. The dataset contains several columns corresponding to quantiles of the family incomes of Americans: \n[Quintile1, Quintile2, median, Quintile3, Quintile4, p95, P90, P95, P99, P99.5, P99.9, P99.99]\n.\n\n\nA plot of the first Quantile against time can be obtained by running:\n\n\nplot(\n    ineq[:Year],\n    ineq[:Quintile1];\n    title=\nIncome inequality in the US\n,\n    xlabel=\nYear\n,\n    ylabel=\nFamily Income(\\$)\n,\n    label=\nFirst Quantile\n\n )\n\n\n\n\n\nSubsequent quantiles can be added to the plot using the \nplot!\n function\n\n\nplot!(ineq[:Year], ineq[:Quintile2], label=\nSecond Quantile\n)\nplot!(ineq[:Year], ineq[:Median], label=\nMedian\n)\nplot!(ineq[:Year], ineq[:Quintile3], label=\nThird Quantile\n)\nplot!(ineq[:Year], ineq[:Quintile4], label=\nFourth Quantile\n)\n\n\n\n\n\n\nA plot of the income development of rich families can be obtained by running:\n\n\nplot(\n    ineq[:Year],\n    ineq[:P90];\n    title=\nIncome inequality in the US\n,\n    xlabel=\nYear\n,\n    ylabel=\nFamily Income(\\$)\n,\n    label=\nP90\n\n )\nplot!(ineq[:Year], ineq[:P95], label=\nP95\n)\nplot!(ineq[:Year], ineq[:P99], label=\nP99\n)\nplot!(ineq[:Year], ineq[:P99_5], label=\nP99.5\n)\nplot!(ineq[:Year], ineq[:P99_9], label=\nP99_9\n)\nplot!(ineq[:Year], ineq[:P99_99], label=\nP99_99\n)\n\n\n\n\n\n\nCleary, P90 and P95 are under-emphasized in the graph. A logarithmic scale can be used by setting the \nyscale\n argument:\n\n\nplot(\n     ineq[:Year],\n     ineq[:P90];\n     title=\nIncome inequality in the US\n,\n     xlabel=\nYear\n,\n     ylabel=\nFamily Income(\\$)\n,\n     label=\nP90\n,\n     yscale=:log10\n )\n plot!(ineq[:Year], ineq[:P95], label=\nP95\n)\n plot!(ineq[:Year], ineq[:P99], label=\nP99\n)\n plot!(ineq[:Year], ineq[:P99_5], label=\nP99.5\n)\n plot!(ineq[:Year], ineq[:P99_9], label=\nP99_9\n)\n plot!(ineq[:Year], ineq[:P99_99], label=\nP99_99\n)\n\n\n\n\n\n\n\n\nHistogram\n\n\nThe example shown below uses the \nBad Health\n dataset available in \nRDatasets\n. The dataset can be loaded using:\n\n\nbhealth = dataset(\nCOUNT\n, \nbadhealth\n)\n\n\n\n\nA histogram of unhealthy people vs age can be plotted by running:\n\n\nhistogram(\n     bhealth[bhealth[:BadH] .== 1, :Age],\n     nbins=10,\n     label=\nNumber of People\n,\n     xlabel=\nAge\n,\n     ylabel=\nNumber of People\n,\n     title=\nAge Distribution of people with Bad Health\n\n )\n\n\n\n\n\n\nMore plotting examples can be obtained at the Plots.jl \ndocumentation\n.\n\n\n\n\nScatterplots\n\n\nCanadian occupational-prestige dataset is another dataset which can be loaded by running:\n\n\njulia\n prestige = dataset(\ncar\n,\nprestige\n);\njulia\n head(prestige)\n6\u00d77 DataFrames.DataFrame\n\u2502 Row \u2502 Profession            \u2502 Education \u2502 Income \u2502 Women \u2502 Prestige \u2502 Census \u2502 Type   \u2502\n\u251c\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\n\u2502 1   \u2502 \ngov.administrators\n  \u2502 13.11     \u2502 12351  \u2502 11.16 \u2502 68.8     \u2502 1113   \u2502 \nprof\n \u2502\n\u2502 2   \u2502 \ngeneral.managers\n    \u2502 12.26     \u2502 25879  \u2502 4.02  \u2502 69.1     \u2502 1130   \u2502 \nprof\n \u2502\n\u2502 3   \u2502 \naccountants\n         \u2502 12.77     \u2502 9271   \u2502 15.7  \u2502 63.4     \u2502 1171   \u2502 \nprof\n \u2502\n\u2502 4   \u2502 \npurchasing.officers\n \u2502 11.42     \u2502 8865   \u2502 9.11  \u2502 56.8     \u2502 1175   \u2502 \nprof\n \u2502\n\u2502 5   \u2502 \nchemists\n            \u2502 14.62     \u2502 8403   \u2502 11.68 \u2502 73.5     \u2502 2111   \u2502 \nprof\n \u2502\n\u2502 6   \u2502 \nphysicists\n          \u2502 15.64     \u2502 11030  \u2502 5.13  \u2502 77.6     \u2502 2113   \u2502 \nprof\n \u2502\n\n\n\n\nScatterplots are useful in visually finding the correlation between two sets of variables:\n\n\njulia\n scatter(prestige[:Income], prestige[:Prestige], xaxis=\nIncome\n, yaxis=\nPrestige\n, title=\nPrestige Vs Income\n)\n\n\n\n\n\n\nIt is often very useful to plot as it reveals the nature of relationships among parameters, from the above figure it can be observed that distribution of income is not very even. Hence it is worth trying to see how \nlog\n would help here:\n\n\njulia\n scatter(log(prestige[:Income]), prestige[:Prestige], xaxis=\nIncome\n, yaxis=\nPrestige\n, title=\nPrestige Vs Income\n)", 
            "title": "Plotting"
        }, 
        {
            "location": "/dataframes/plotting/#plotting", 
            "text": "The  Plots.jl  package is probably the best option for  linegraphs ,  scatterplots ,  histograms  etc.", 
            "title": "Plotting"
        }, 
        {
            "location": "/dataframes/plotting/#line-graphs", 
            "text": "The examples shown below use the  Income Inequality in the US  dataset which can be loaded by running:  julia  ineq = dataset( Ecdat ,  incomeInequality )  It would be interesting to see how the family incomes of the different sections of society have developed over the years. The dataset contains several columns corresponding to quantiles of the family incomes of Americans:  [Quintile1, Quintile2, median, Quintile3, Quintile4, p95, P90, P95, P99, P99.5, P99.9, P99.99] .  A plot of the first Quantile against time can be obtained by running:  plot(\n    ineq[:Year],\n    ineq[:Quintile1];\n    title= Income inequality in the US ,\n    xlabel= Year ,\n    ylabel= Family Income(\\$) ,\n    label= First Quantile \n )  Subsequent quantiles can be added to the plot using the  plot!  function  plot!(ineq[:Year], ineq[:Quintile2], label= Second Quantile )\nplot!(ineq[:Year], ineq[:Median], label= Median )\nplot!(ineq[:Year], ineq[:Quintile3], label= Third Quantile )\nplot!(ineq[:Year], ineq[:Quintile4], label= Fourth Quantile )   A plot of the income development of rich families can be obtained by running:  plot(\n    ineq[:Year],\n    ineq[:P90];\n    title= Income inequality in the US ,\n    xlabel= Year ,\n    ylabel= Family Income(\\$) ,\n    label= P90 \n )\nplot!(ineq[:Year], ineq[:P95], label= P95 )\nplot!(ineq[:Year], ineq[:P99], label= P99 )\nplot!(ineq[:Year], ineq[:P99_5], label= P99.5 )\nplot!(ineq[:Year], ineq[:P99_9], label= P99_9 )\nplot!(ineq[:Year], ineq[:P99_99], label= P99_99 )   Cleary, P90 and P95 are under-emphasized in the graph. A logarithmic scale can be used by setting the  yscale  argument:  plot(\n     ineq[:Year],\n     ineq[:P90];\n     title= Income inequality in the US ,\n     xlabel= Year ,\n     ylabel= Family Income(\\$) ,\n     label= P90 ,\n     yscale=:log10\n )\n plot!(ineq[:Year], ineq[:P95], label= P95 )\n plot!(ineq[:Year], ineq[:P99], label= P99 )\n plot!(ineq[:Year], ineq[:P99_5], label= P99.5 )\n plot!(ineq[:Year], ineq[:P99_9], label= P99_9 )\n plot!(ineq[:Year], ineq[:P99_99], label= P99_99 )", 
            "title": "Line Graphs"
        }, 
        {
            "location": "/dataframes/plotting/#histogram", 
            "text": "The example shown below uses the  Bad Health  dataset available in  RDatasets . The dataset can be loaded using:  bhealth = dataset( COUNT ,  badhealth )  A histogram of unhealthy people vs age can be plotted by running:  histogram(\n     bhealth[bhealth[:BadH] .== 1, :Age],\n     nbins=10,\n     label= Number of People ,\n     xlabel= Age ,\n     ylabel= Number of People ,\n     title= Age Distribution of people with Bad Health \n )   More plotting examples can be obtained at the Plots.jl  documentation .", 
            "title": "Histogram"
        }, 
        {
            "location": "/dataframes/plotting/#scatterplots", 
            "text": "Canadian occupational-prestige dataset is another dataset which can be loaded by running:  julia  prestige = dataset( car , prestige );\njulia  head(prestige)\n6\u00d77 DataFrames.DataFrame\n\u2502 Row \u2502 Profession            \u2502 Education \u2502 Income \u2502 Women \u2502 Prestige \u2502 Census \u2502 Type   \u2502\n\u251c\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\n\u2502 1   \u2502  gov.administrators   \u2502 13.11     \u2502 12351  \u2502 11.16 \u2502 68.8     \u2502 1113   \u2502  prof  \u2502\n\u2502 2   \u2502  general.managers     \u2502 12.26     \u2502 25879  \u2502 4.02  \u2502 69.1     \u2502 1130   \u2502  prof  \u2502\n\u2502 3   \u2502  accountants          \u2502 12.77     \u2502 9271   \u2502 15.7  \u2502 63.4     \u2502 1171   \u2502  prof  \u2502\n\u2502 4   \u2502  purchasing.officers  \u2502 11.42     \u2502 8865   \u2502 9.11  \u2502 56.8     \u2502 1175   \u2502  prof  \u2502\n\u2502 5   \u2502  chemists             \u2502 14.62     \u2502 8403   \u2502 11.68 \u2502 73.5     \u2502 2111   \u2502  prof  \u2502\n\u2502 6   \u2502  physicists           \u2502 15.64     \u2502 11030  \u2502 5.13  \u2502 77.6     \u2502 2113   \u2502  prof  \u2502  Scatterplots are useful in visually finding the correlation between two sets of variables:  julia  scatter(prestige[:Income], prestige[:Prestige], xaxis= Income , yaxis= Prestige , title= Prestige Vs Income )   It is often very useful to plot as it reveals the nature of relationships among parameters, from the above figure it can be observed that distribution of income is not very even. Hence it is worth trying to see how  log  would help here:  julia  scatter(log(prestige[:Income]), prestige[:Prestige], xaxis= Income , yaxis= Prestige , title= Prestige Vs Income )", 
            "title": "Scatterplots"
        }, 
        {
            "location": "/ml/regressions/", 
            "text": "Regressions\n\n\n\n\nLinear Regression on DataFrames\n\n\nThe examples shown below use the \nIncome Inequality in the US\n dataset which can be loaded by running:\n\n\njulia\n ineq = dataset(\nEcdat\n, \nincomeInequality\n)\n\n\n\n\nFitting \nRealGDPPerFamily\n to the \nYear\n is as simple as:\n\n\nlinearmodel = fit(LinearModel, RealGDPPerFamily ~ Year, ineq)\nc, m = coef(linearmodel)\nf(x) = m*x + c\nplot(\n   ineq[:Year],\n   ineq[:RealGDPPerFamily],\n   smooth=true,\n   seriestype=:scatter,\n   title = \nRealGDPPerFamily vs Year\n,\n   linewidth=8,\n   linealpha=0.5,\n   label=\ndata\n\n   )\n\nplot!(f, 1950, 2020, label=\ncorrelation\n)\n\n\n\n\n\n\n\n\nMinimum Least Squares on Arbitrary Functions\n\n\nYou have a function \ny = f(x)\n, and you want to use want to predict the values of y:\n\n\nusing DataFrames\nusing GLM\nusing Plots\n\ne = 2.3\nf(x) = x ^ e + 1\ndf = DataFrame(X = collect(1 : 100), Y = map(f, 1 : 100))\n\nOLS = glm(Y ~ X, df, Normal(), IdentityLink())\n\nplot(\n   df[:X],\n   df[:Y],\n   smooth=true,\n   seriestype=:scatter,\n   linewidth=8,\n   linealpha=0.5,\n   label=\ndata\n\n)\n\nplot!(df[:X], predict(OLS), label=\nCorrelation\n)", 
            "title": "Regressions"
        }, 
        {
            "location": "/ml/regressions/#regressions", 
            "text": "", 
            "title": "Regressions"
        }, 
        {
            "location": "/ml/regressions/#linear-regression-on-dataframes", 
            "text": "The examples shown below use the  Income Inequality in the US  dataset which can be loaded by running:  julia  ineq = dataset( Ecdat ,  incomeInequality )  Fitting  RealGDPPerFamily  to the  Year  is as simple as:  linearmodel = fit(LinearModel, RealGDPPerFamily ~ Year, ineq)\nc, m = coef(linearmodel)\nf(x) = m*x + c\nplot(\n   ineq[:Year],\n   ineq[:RealGDPPerFamily],\n   smooth=true,\n   seriestype=:scatter,\n   title =  RealGDPPerFamily vs Year ,\n   linewidth=8,\n   linealpha=0.5,\n   label= data \n   )\n\nplot!(f, 1950, 2020, label= correlation )", 
            "title": "Linear Regression on DataFrames"
        }, 
        {
            "location": "/ml/regressions/#minimum-least-squares-on-arbitrary-functions", 
            "text": "You have a function  y = f(x) , and you want to use want to predict the values of y:  using DataFrames\nusing GLM\nusing Plots\n\ne = 2.3\nf(x) = x ^ e + 1\ndf = DataFrame(X = collect(1 : 100), Y = map(f, 1 : 100))\n\nOLS = glm(Y ~ X, df, Normal(), IdentityLink())\n\nplot(\n   df[:X],\n   df[:Y],\n   smooth=true,\n   seriestype=:scatter,\n   linewidth=8,\n   linealpha=0.5,\n   label= data \n)\n\nplot!(df[:X], predict(OLS), label= Correlation )", 
            "title": "Minimum Least Squares on Arbitrary Functions"
        }
    ]
}